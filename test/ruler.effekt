import test

import lib/utils
import lib/net/net
import lib/language/lc/compiler
import lib/language/lc/term
import lib/language/ic/term
import lib/language/ic/ruler

// normalize is non-deterministic
def confluence[R] { test: => R }: R = {
  0.each(10) { _ => test(); () }
  test()
}

def tests() = suite("â”” ruler tests") {
  test("normalization: identity application") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    assertEqual(list::collect[Redex] { redexes() }, [
      Redex(
        Applicator(Neg("kAbs2"), Neg("kAbs4"), Pos("kApp5")),
        Abstractor(Pos("xSym1"), Neg("xSym1"), Pos("kAbs2")))
    ])
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 1)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym3"), Neg("xSym3"), Pos("kAbs4"))
    ])
  }

  test("normalization: identity duplication") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 3)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym6_1_1"), Neg("xSym6_1_1"), Pos("xSym2"))
    ])
  }

  test("normalization: more complex identity annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 4)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym9_1_1"), Neg("xSym9_1_1"), Pos("xSym4"))
    ])
  }

  test("normalization: multi-arity identity annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      // TODO: is this supposed to work??
      // with source[Char] { "(x=>x x=>(x x x x x x) x=>(x x) x=>x)".each }
      with source[Char] { "(x=>(x x x x x x x x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 10)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym20_8_8"), Neg("xSym20_8_8"), Pos("xSym16"))
    ])
  }

  test("normalization: church identity annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(s=>z=>(s (s (s (s (s z))))) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 7)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("zSym6"), Neg("zSym6"), Pos("kAbs12"))
    ])
  }

  // TODO: this works, but only without optimizations ("b_k_0 is not defined")
  test("normalization: erasing church") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>y=>y s=>z=>(s (s (s z))))".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 11)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("ySym1"), Neg("ySym1"), Pos("kAbs2"))
    ])
  }
}