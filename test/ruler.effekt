import test

import lib/utils
import lib/net/net
import lib/language/lc/compiler
import lib/language/lc/term
import lib/language/ic/term
import lib/language/ic/ruler

def normalize(program: Program, redexes: RedexBag): (Program, Int) = {
  var count = 0
  var state = (program, redexes)
  with exhaustively((empty(), 0))
  count = count + 1
  state = returning::collect {
    collect { state.first.step(state.second) } }
  if (count > 100) do fail()
  (state.first, count)
}

def tests() = suite("â”” ruler tests") {
  test("normalization: identity application") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    assertEqual(list::collect[Redex] { redexes() }, [
      Redex(
        Constructor(Port("kAbs2", Neg()), [Port("kAbs5", Neg()), Port("kApp7", Pos())], LightTriangle()),
        Constructor(Port("kAbs2", Pos()), [Port("xDup3", Pos()), Port("xSym1", Neg())], LightTriangle()))
    ])
    val (normalized, steps) = normalize(program, redexes)
    assertEqual(steps, 2)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Constructor(Port("xSym1", Pos()), [Port("xDup6", Pos()), Port("xSym4", Neg())], LightTriangle()),
      Constructor(Port("xDup6", Neg()), [Port("xSym4", Pos())], DarkTriangle())])
  }

  test("normalization: identity duplication") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes)
    assertEqual(steps, 5)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Constructor(Port("xSym2", Pos()), [Port("xDup8_1", Pos()), Port("xDup8_1", Neg())], LightTriangle())])
  }

  test("normalization: ternary identity duplication") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>(x x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes)
    assertEqual(steps, 8)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Constructor(Port("xSym4", Pos()), [Port("xDup11_1", Pos()), Port("xDup11_1", Neg())], LightTriangle())])
  }

  test("normalization: erasing church") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>y=>y s=>z=>(s (s (s z))))".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes)
    assertEqual(steps, 13)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Constructor(Port("yDup3", Neg()), [Port("ySym1", Pos())], DarkTriangle()),
      Constructor(Port("kAbs2", Pos()), [Port("yDup3", Pos()), Port("ySym1", Neg())], LightTriangle())])
  }
}