import test
import tty
import set

import lib/utils
import lib/net/net
import lib/language/lc/compiler
import lib/language/lc/term
import lib/language/ic/term
import lib/language/ic/ruler

// normalize is non-deterministic
def confluence { test: => Unit / Assertion }: Unit / Assertion = {
  0.each(50) { i =>
    try test()
    with Assertion {
      def assert(condition, msg) = do assert(condition, s"${msg} (run number ${i.show})")
    }
  }
  test()
}

// for now mostly heuristics
def assertEquivalent(bs: List[Constructor], as: List[Constructor]): Unit / { Formatted, Assertion } = {
  // TODO: ordering?
  // TODO: map for actual alpha equivalence

  val aPorts = fromListGeneric(as.flatMap { ctor => ctor.ports.map { p => p.name } })
  val bPorts = fromListGeneric(bs.flatMap { ctor => ctor.ports.map { p => p.name } })
  assertEqual(aPorts.size, bPorts.size, s"Expected ${aPorts.size.show} unique variables, but got ${bPorts.size.show}:\n" ++ aPorts.toList.show ++ " vs " ++ bPorts.toList.show ++ "\nin " ++ as.show ++ "\nvs " ++ bs.show)

  as.zip(bs).foreach {
    case (Abstractor(Pos(x1), Neg(b1), Pos(k1)), Abstractor(Pos(x2), Neg(b2), Pos(k2))) => ()
    case (Applicator(Neg(f1), Neg(a1), Pos(k1)), Applicator(Neg(f2), Neg(a2), Pos(k2))) => ()
    case (Duplicator(Neg(o1), ins1, label1), Duplicator(Neg(o2), ins2, label2)) =>
      assertEqual(ins1.size, ins2.size)
      assertEqual(label1, label2)
    case (Superposer(Pos(i1), out1, label1), Superposer(Pos(i2), out2, label2)) =>
      assertEqual(out1.size, out2.size)
      assertEqual(label1, label2)
    case (Initiator(Neg(k1)), Initiator(Neg(k2))) => ()
    case (_, _) => assertEqual(as, bs) { (a, b) => a == b } { c => c.show } // will fail, but we'll see why
  }
  assertEqual(as.size, bs.size)
}

def tests() = suite("â”” ruler tests") {
  test("normalization: identity application") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    assertEqual(list::collect[Redex] { redexes() }, [
      Redex(
        Applicator(Neg("kAbs2".ref), Neg("kAbs4".ref), Pos("kApp5".ref)),
        Abstractor(Pos("xSym1".ref), Neg("xSym1".ref), Pos("kAbs2".ref)))
    ]) { (a, b) => a == b } { r => r.show }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 1)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym3".ref), Neg("xSym3".ref), Pos("xSym1".ref)),
      Initiator(Neg("xSym1".ref))
    ])
  }

  test("normalization: identity duplication") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 4)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym6_1_1".ref), Neg("xSym6_1_1".ref), Pos("xSym6_0_0".ref)),
      Initiator(Neg("xSym6_0_0".ref))
    ])
  }

  test("normalization: more complex identity annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 5)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym9_1_1".ref), Neg("xSym9_1_1".ref), Pos("xSym9_0_0".ref)),
      Initiator(Neg("xSym9_0_0".ref))
    ])
  }

  test("normalization: multi-arity identity annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>(x x x x x x x x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 11)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym20_8_8".ref), Neg("xSym20_8_8".ref), Pos("xSym20_7_7".ref)),
      Initiator(Neg("xSym20_7_7".ref))
    ])
  }

  test("normalization: church identity annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(s=>z=>(s (s (s (s (s (s z)))))) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 9)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xSym9_1_1".ref), Neg("xSym9_1_1".ref), Pos("kAbs6".ref)),
      Initiator(Neg("kAbs6".ref))
    ])
  }

  /*test("normalization: church i* annihilation") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(s=>z=>(s (s (s (s (s (s z)))))) x=>y=>(x y))".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 17)
    assertEquivalent(list::collect[Constructor] { normalized() }, [ // x => y => (x y)
      Applicator(Neg("xSym17_5_5"), Neg("ySym18_17_5"), Pos("kApp19_19_1")), // (x y)
      Abstractor(Pos("ySym18_17_5"), Neg("kApp19_19_1"), Pos("kAbs20_6_0")), // y =>
      Abstractor(Pos("xSym17_5_5"), Neg("kAbs20_6_0"), Pos("kAbs14")),       // x =>
      Initiator(Neg("kAbs14"))
    ])
  }

  test("normalization: church bruijnification") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(s=>z=>(s (s z)) x=>y=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 7)
    assertEquivalent(list::collect[Constructor] { normalized() }, [ // x9_4 => y11_4 => y11_5 => x9_4
      Duplicator(Neg("yEra11_4_0"), Nil(), 1),
      Duplicator(Neg("yEra11_5_1"), Nil(), 1),
      Abstractor(Pos("yEra11_4_0"), Neg("xSym9_0_0"), Pos("kAbs10_2_0")), // y11_4 =>
      Abstractor(Pos("yEra11_5_1"), Neg("xSym9_1_1"), Pos("xSym9_0_0")),  // y11_5 =>
      Abstractor(Pos("xSym9_1_1"), Neg("kAbs10_2_0"), Pos("kAbs6")),      // x9 =>
      Initiator(Neg("kAbs6"))
    ])
  }

  test("normalization: erasing church") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>y=>y s=>z=>(s (s (s z))))".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 11)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("ySym1"), Neg("ySym1"), Pos("kAbs2")),
      Initiator(Neg("kAbs2"))
    ])
  }

  test("normalization: s k k") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>y=>z=>(x z (y z)) x=>y=>x x=>y=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 7)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Duplicator(Neg("zSym5"), Nil(), 1),
      Duplicator(Neg("zDup9"), [Pos("zSym2"), Pos("zSym5")], 0),
      Abstractor(Pos("zDup9"), Neg("zSym2"), Pos("kAbs8")),
      Initiator(Neg("kAbs8"))
    ])
  }

  val iota = "s=>(s x=>y=>z=>(x z (y z)) x=>y=>x)"

  test("normalization: iota iota") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { s"(${iota} ${iota})".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 19)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Duplicator(Neg("zDup29"), [Pos("zSym22"), Pos("zSym25")], 2),
      Abstractor(Pos("zDup29"), Neg("zSym22"), Pos("kAbs28")),
      Duplicator(Neg("zSym25"), [], 2),
      Initiator(Neg("kAbs28"))
    ])
  }

  test("normalization: iota iota iota iota") {
    with confluence
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { s"(${iota} (${iota} (${iota} ${iota})))".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 70)
    assertEqual(steps, 63)
    assertEquivalent(list::collect[Constructor] { normalized() }, [
      Duplicator(Neg("38"), Nil(), 1),
      Abstractor(Pos("38"), Neg("34"), Pos("36")),   // y => x
      Abstractor(Pos("34"), Neg("36"), Pos("32_0")), // x =>
      Initiator(Neg("32_0"))
    ])
  }*/
}
