import test

import lib/utils
import lib/net/net
import lib/language/lc/compiler
import lib/language/lc/term
import lib/language/ic/term
import lib/language/ic/ruler

def tests() = suite("â”” ruler tests") {
  test("normalization: identity application") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    assertEqual(list::collect[Redex] { redexes() }, [
      Redex(
        Applicator(Neg("kAbs2"), Neg("kAbs5"), Pos("kApp7")),
        Abstractor(Pos("xDup3"), Neg("xSym1"), Pos("kAbs2")))
    ])
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 3)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Duplicator(Neg("xSym4"), [Pos("xSym4_0")], 0),
      Abstractor(Pos("xSym4"), Neg("xSym4_0"), Pos("xSym1"))
    ])
  }

  test("normalization: identity duplication") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 10)
    assertEqual(steps, 5)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xDup8_1"), Neg("xDup8_1"), Pos("xSym2"))
    ])
  }

  test("normalization: more complex identity annihilation") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      with source[Char] { "(x=>x x=>(x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 10)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Abstractor(Pos("xDup12_1_0"), Neg("xDup12_1_0"), Pos("kApp6_0"))
    ])
  }

  test("normalization: multi-arity identity annihilation") {
    val program: Program = collect {
      with assertNoThrow[WrongFormat]
      // with source[Char] { "(x=>x x=>(x x x x x x) x=>(x x) x=>x)".each } // TODO: is this supposed to work?
      with source[Char] { "(x=>x x=>(x x x x x x) x=>x)".each }
      compile!()
    }
    val redexes = box { program.redexes() }
    val (normalized, steps) = normalize(program, redexes, 20)
    assertEqual(steps, 9)
    assertEqual(list::collect[Constructor] { normalized() }, [
      Duplicator(Neg("xDup8_1_0"), [Pos("xSym6_1_0")], 1),
      Abstractor(Pos("xDup8_1_0"), Neg("xSym6_1_0"), Pos("xSym2_0"))
    ])
  }

  // test("normalization: ternary identity duplication") {
  //   val program: Program = collect {
  //     with assertNoThrow[WrongFormat]
  //     with source[Char] { "(x=>(x x x) x=>x)".each }
  //     compile!()
  //   }
  //   val redexes = box { program.redexes() }
  //   val (normalized, steps) = normalize(program, redexes, 100)
  //   assertEqual(steps, 8)
  //   assertEqual(list::collect[Constructor] { normalized() }, [
  //     Constructor(Port("xSym4", Pos()), [Port("xDup11_1", Pos()), Port("xDup11_1", Neg())], LightTriangle())])
  // }

  // TODO: this works, but only without optimizations ("b_k_0 is not defined")
  // test("normalization: erasing church") {
  //   val program: Program = collect {
  //     with assertNoThrow[WrongFormat]
  //     with source[Char] { "(x=>y=>y s=>z=>(s (s (s z))))".each }
  //     compile!()
  //   }
  //   val redexes = box { program.redexes() }
  //   val (normalized, steps) = normalize(program, redexes)
  //   assertEqual(steps, 13)
  //   assertEqual(list::collect[Constructor] { normalized() }, [
  //     Constructor(Port("yDup3", Neg()), [Port("ySym1", Pos())], DarkTriangle()),
  //     Constructor(Port("kAbs2", Pos()), [Port("yDup3", Pos()), Port("ySym1", Neg())], LightTriangle())])
  // }
}