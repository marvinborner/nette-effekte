import map

import app/net

import lib/language/ic/term
import lib/language/ic/ruler
import lib/language/ic/netter
import lib/net/net
import lib/ui/geometry
import lib/ui/dirty
import lib/ui/vector
import lib/ui/canvas
import lib/net/layout

record NetState(net: Net, program: Program, redexes: RedexBag, canvas: Canvas)

type CanvasOp {
  Size(size: Vector)
  Pan(offset: Vector)
  Zoom(delta: Double)
}

def empty(): Net = box {}
def empty(): Program = box {}
def empty(): RedexBag = box {}
def empty() = NetState(empty(), empty(), empty(), empty())

type WireResolver { Resolved(position: Vector); Unresolved(label: Label) }

def resolveWire(resolver: WireResolver, label: Label, position: Vector): WireResolver = resolver match {
  case Unresolved(l) and l == label => Resolved(position)
  case _ => resolver
}

def render(state: NetState): Unit / { Draw, NetStream } = {
  var positions: Map[Label, Vector] = emptyGeneric()
  var wires: List[Tuple2[WireResolver, WireResolver]] = Nil()

  def resolve(label: Label, position: Vector) = {
    positions = positions.put(label, position)
    wires = wires.map {
      case (a, b) => (a.resolveWire(label, position), b.resolveWire(label, position))
    }
  }

  try layout { (state.net)() }
  with emit[Agent] { agent =>
    do emit(agent)
    val triangle = Triangle(agent.pos, 100.0, agent.aux.size)
    agent.pp.resolve(triangle.principal)
    agent.aux.foreachIndex { (i, port) => port.resolve(triangle.auxiliary(i)) }
    resume(do emit(triangle))
  }
  with emit[Wire] { wire =>
    do emit(wire)
    val from = positions.get(wire.from).map { pos => Resolved(pos) }.getOrElse { Unresolved(wire.from) }
    val to   = positions.get(wire.to).map   { pos => Resolved(pos) }.getOrElse { Unresolved(wire.to) }
    resume((wires = Cons((from, to), wires)))
  }

  wires.foreach {
    case (Resolved(from), Resolved(to)) => do emit(Arrow(from, to))
    case _ => panic("unresolved wires (should be impossible by now)")
  }
}

def render(state: NetState): NetState / Redraw = {
  val t: (Canvas, Net) = returning::collect {
    val canvas = state.canvas.draw { state.render() }
    canvas
  }
  do redrawCallee()
  NetState(t.second, state.program, state.redexes, t.first)
}

def operation(state: NetState, op: CanvasOp): NetState / Redraw = op match {
  case Size(s) => NetState(state.net, state.program, state.redexes, state.canvas.setSize(s)) // no render!
  case Pan(o)  => NetState(state.net, state.program, state.redexes, state.canvas.addOffset(o)).render()
  case Zoom(d) => NetState(state.net, state.program, state.redexes, state.canvas.map { sc => sc * 1.1.pow(d) }).render()
}

def load(state: NetState) { prog: => Unit / emit[Constructor] }: NetState / Redraw = {
  with on[WrongFormat].panic // impossible by now
  val program: Program = collect { prog() }
  val net: Net = collect { source[Constructor] { program() } { net!() } }
  val redexes: RedexBag = collect { program.redexes() }
  do redrawCallee()
  NetState(net, program, redexes, state.canvas)
}

def step(state: NetState): NetState / Redraw = {
  val (loaded, redexes) = returning::collect {
    state.load { state.program.step(state.redexes) } }
  NetState(loaded.net, loaded.program, redexes, loaded.canvas)
}

def interactive[R] { prog: => R / NetModel[NetState, Canvas, CanvasOp] }: R =
  try prog()
  with NetModel[NetState, Canvas, CanvasOp] {
    def empty() = resume(empty())
    def context(net) = resume(net.canvas)
    def load(net) = resume { { prog } => net.load { prog } }
    def render(net) = resume { net.render }
    def step(net) = resume { net.step }
    def operation(net, op) = resume { net.operation(op) }
  }
