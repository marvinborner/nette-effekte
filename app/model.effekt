import map

import app/net
import lib/net/net

import lib/ui/model
import lib/ui/dirty
import lib/ui/vector
import lib/language/ic/term
import lib/language/ic/ruler
import lib/language/ic/parser
import lib/language/ic/compiler
import lib/language/lc/compiler

extern def interactive(): Bool =
  jsWeb "true"
  default { false }

// TODO: add SourceLanguage
type Mode { LambdaCalculus(); InteractionCalculus() }

type TextStream = => Unit / emit[Char] at {global}
record EvaluatorState[N](mode: Mode, sources: Map[Mode, TextStream], net: N, errors: String)

def map[A, B](state: EvaluatorState[A]) { f: A => B }: EvaluatorState[B] = state match {
  case EvaluatorState(mode, sources, net, errors) =>
    EvaluatorState(mode, sources, f(net), errors)
}

def modifyState[N] { f: N => N }: Unit / State[EvaluatorState[N]] =
  do setState((do getState()).map { net => f(net) })

interface Model[C, O] {
  def render(): Unit / Redraw
  def stepReduction(): Unit / Redraw
  def normalize(): Unit / Redraw
  def stepAnimation(): Unit / Redraw
  def nextMode(): Unit / Redraw
  def setSource(s: String): Unit / Redraw
  def onContext(op: O): Unit / Redraw

  def getMode(): Mode
  def getSource(mode: Mode): TextStream
  def getContext(): C
  def getErrors(): String
}

def show(m: Mode) = m match {
  case LambdaCalculus()      => "Lambda Calculus"
  case InteractionCalculus() => "Interaction Calculus"
}

def empty[N, C, O](): EvaluatorState[N] / NetModel[N, C, O] = {
  var map = map::emptyGeneric[Mode, TextStream]()
  val emptyStream: => Unit / emit[Char] at {global} = box{}
  map = map.put(LambdaCalculus(), emptyStream)
  map = map.put(InteractionCalculus(), emptyStream)
  EvaluatorState(LambdaCalculus(), map, do empty(), "")
}

def report[E, N](proxy: on[E], rollback: EvaluatorState[N]) { prog: => EvaluatorState[N] / Exception[E] }: EvaluatorState[N] =
  try { prog() } with Exception[E] {
    def raise(exception: E, msg: String) = {
      println(msg)
      EvaluatorState(rollback.mode, rollback.sources, rollback.net, msg)
    }
  }

def nextMode[N](state: EvaluatorState[N]): EvaluatorState[N] / Redraw = {
  do redrawFull()
  state match {
    case EvaluatorState(LambdaCalculus(), sources, net, errors)      => EvaluatorState(InteractionCalculus(), sources, net, errors)
    case EvaluatorState(InteractionCalculus(), sources, net, errors) => EvaluatorState(LambdaCalculus(), sources, net, errors)
  }
}

def setSource[N](state: EvaluatorState[N], s: String): EvaluatorState[N] / Redraw = {
  if (not(interactive())) // redraw only on terminal.. (TODO?)
    do redrawFull()

  state match {
    case EvaluatorState(mode, sources, net, errors) => {
      // this would have been so cool but would only work for linear ASCII input (no escape, arrow keys)
      // val currentStream = sources.getOrElse(mode){<>}
      // val newStream = box { do emit(c); currentStream() }
      EvaluatorState(mode, sources.put(mode, box { s.each }), net, errors)
    }
  }
}

// compile + load + render
def render[N, C, O](state: EvaluatorState[N]): EvaluatorState[N] / { NetModel[N, C, O], Redraw } = {
  do redrawFull() // for errors

  with on[MissingValue].panic // should be impossible by now
  with on[WrongFormat].report(state)
  with returning::source[Char, EvaluatorState[N]] {
    (state.sources.get(state.mode).value)()
  }
  state match {
    case EvaluatorState(InteractionCalculus(), sources, net, errors) => {
      val net_ = do render(do load(net) { ic::compile!() })
      EvaluatorState(InteractionCalculus(), sources, net_, "")
    }
    case EvaluatorState(LambdaCalculus(), sources, net, errors) => {
      val prog: Program = collect { lc::compile!() } // reify for storing in IC source
      val sources_ = sources.put(InteractionCalculus(), box { prog.show.each })
      val net_ = do render(do load(net) { prog() })
      EvaluatorState(LambdaCalculus(), sources_, net_, "")
    }
  }
}

def model[C, O, R, N] { prog: => R / Model[C, O] }: R / { State[EvaluatorState[N]], NetModel[N, C, O] } =
  with on[MissingValue].panic // should be impossible by now
  with freshener

  try { prog() }
  with Model[C, O] {
    def render()        = resume { modifyState { st => st.render } }
    def stepReduction() = resume { modifyState { net => do step(net) } }
    def normalize()     = resume { modifyState { net => do normalize(net) } }
    def stepAnimation() = resume { modifyState { net => do render(net) } }
    def nextMode()      = resume { modifyState { st => st.nextMode } }
    def setSource(c)    = resume { modifyState { st => st.setSource(c) } }
    def onContext(op)   = resume { modifyState { net => do operation(net, op) } }

    def getMode() = resume((do getState()).mode)
    def getSource(mode) = {
      val source = (do getState()).sources.get(mode).value
      resume(source)
    }
    def getErrors() = resume((do getState()).errors)
    def getContext() = resume(do context((do getState()).net))
  }
