import map

import app/interactive
import lib/net/net

import lib/ui/model
import lib/ui/canvas
import lib/ui/vector
import lib/language/ic/parser
import lib/language/ic/compiler

import lib/language/ic/term

type Mode { SourceLanguage(); LambdaCalculus(); InteractionCalculus() }

type TextStream = => Unit / emit[Char] at {global}
record EvaluatorState(mode: Mode, sources: Map[Mode, TextStream], net: NetState, errors: String)

interface Model {
  def render(): Unit
  def stepReduction(): Unit
  def stepAnimation(): Unit
  def nextMode(): Unit
  def setSource(s: String): Unit
  def setCanvasSize(v: Vector): Unit

  def getMode(): Mode
  def getSource(mode: Mode): TextStream
  def getCanvas(): Canvas
  def getErrors(): String
}

def show(m: Mode) = m match {
  case SourceLanguage()      => "Source Language"
  case LambdaCalculus()      => "Lambda Calculus"
  case InteractionCalculus() => "Interaction Calculus"
}

def empty() = {
  var map = map::emptyGeneric[Mode, TextStream]()
  val emptyStream: => Unit / emit[Char] at {} = box{}
  map = map.put(SourceLanguage(), emptyStream)
  map = map.put(LambdaCalculus(), emptyStream)
  map = map.put(InteractionCalculus(), emptyStream)
  // EvaluatorState(SourceLanguage(), map, empty(), "")
  EvaluatorState(InteractionCalculus(), map, empty(), "")
}

def report[E](proxy: on[E], rollback: EvaluatorState) { prog: => EvaluatorState / Exception[E] }: EvaluatorState =
  try { prog() } with Exception[E] {
    def raise(exception: E, msg: String) = {
      println(msg)
      EvaluatorState(rollback.mode, rollback.sources, rollback.net, msg)
    }
  }

def nextMode(state: EvaluatorState): EvaluatorState = state match {
  case EvaluatorState(SourceLanguage(), sources, net, errors)      => EvaluatorState(LambdaCalculus(), sources, net, errors)
  case EvaluatorState(LambdaCalculus(), sources, net, errors)      => EvaluatorState(InteractionCalculus(), sources, net, errors)
  case EvaluatorState(InteractionCalculus(), sources, net, errors) => EvaluatorState(SourceLanguage(), sources, net, errors)
}

def setSource(state: EvaluatorState, s: String): EvaluatorState = state match {
  case EvaluatorState(mode, sources, net, errors) => {
    // this would have been so cool but would only work for linear ASCII input (no escape, arrow keys)
    // val currentStream = sources.getOrElse(mode){<>}
    // val newStream = box { do emit(c); currentStream() }
    EvaluatorState(mode, sources.put(mode, box { s.each }), net, errors)
  }
}

def setCanvasSize(state: EvaluatorState, size: Vector): EvaluatorState = state match {
  case EvaluatorState(mode, sources, net, errors) => {
    EvaluatorState(mode, sources, net.setCanvasSize(size), errors)
  }
}

def stepAnimation(state: EvaluatorState): EvaluatorState = state match {
  case EvaluatorState(mode, sources, net, errors) => {
    EvaluatorState(mode, sources, net.render(), errors)
  }
}

def render(state: EvaluatorState): EvaluatorState =
  with on[MissingValue].panic // should be impossibly by now
  with on[WrongFormat].report(state)
  with returning::source[Char, EvaluatorState] {
    (state.sources.get(state.mode).value)()
  }
  state match {
    case EvaluatorState(InteractionCalculus(), sources, net, errors) => {
      val net_ = render(state.net.load { compile!() })
      EvaluatorState(InteractionCalculus(), sources, net_, "")
    }
    case _ => <>
}

def model[R] { prog: => R / Model }: R / State[EvaluatorState] =
  with on[MissingValue].panic // should be impossibly by now

  try { prog() }
  with Model {
    def render() = resume(modifyState { st => st.render })
    def stepReduction() = <>
    def stepAnimation() = resume(modifyState { st => st.stepAnimation })
    def nextMode() = resume(modifyState { st => st.nextMode })
    def setSource(c) = resume(modifyState { st => st.setSource(c) })
    def setCanvasSize(v) = resume(modifyState { st => st.setCanvasSize(v) })

    def getMode() = resume((do getState()).mode)
    def getSource(mode) = {
      val state = do getState()
      val source = state.sources.get(mode).value
      resume(source)
    }
    def getErrors() = resume((do getState()).errors)
    def getCanvas() = resume((do getState()).net.canvas)
  }
