import map

import lib/net/net
import lib/ui/geometry
import lib/ui/canvas

record NetState(net: Net, canvas: Canvas)

def empty(): Net = box {}
def empty() = NetState(empty(), empty())

effect lookup(label: Label): Vector

// wires are often emitted before agents, we need to match them bidirectionally!
def render(state: NetState): Unit / Geometry = {
  var positions: Map[Label, Vector] = emptyGeneric()
  try (state.net)()
  with emit[Agent] { agent =>
    val triangle = Triangle(agent.pos, 100.0)
    positions = positions.put(agent.pp, principal(triangle))
    
    // where foldRightIndex?
    positions = foldRight(agent.aux, (positions, 0)) { (port, tup) => {
      val (mp, i) = tup
      (mp.put(port, auxiliary(triangle, i)), i + 1)
    } }.first
    resume(triangle.dispatch)
  }
  with emit[Wire] { wire =>
    val from = positions.getOrElse(wire.from) { panic("no position") }
    val to = positions.getOrElse(wire.to) { panic("no position") }
    resume(do arrow(from, to))
    // val from = positions.getOrElse(wire.from) { resume(do lookup(wire.from)) }
    // val to = positions.getOrElse(wire.to) { resume(do lookup(wire.to)) }
  }
}

def render(state: NetState): NetState = {
  val canvas = applyGeometry { render(state) }
  NetState(state.net, canvas)
}

def loadNet { prog: => Unit / NetStream }: NetState = {
  val net = collect { prog() }
  NetState(net, empty())
}