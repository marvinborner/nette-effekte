import map

import lib/net/net
import lib/ui/geometry
import lib/ui/vector
import lib/ui/canvas
import lib/net/layout

record NetState(net: Net, canvas: Canvas)

def empty(): Net = box {}
def empty() = NetState(empty(), empty())

type WireResolver { Resolved(position: Vector); Unresolved(label: Label) }

def resolveWire(resolver: WireResolver, label: Label, position: Vector): WireResolver = resolver match {
  case Unresolved(l) and l == label => Resolved(position)
  case _ => resolver
}

def render(state: NetState): Unit / { Draw, NetStream } = {
  var positions: Map[Label, Vector] = emptyGeneric()
  var wires: List[Tuple2[WireResolver, WireResolver]] = Nil()

  def resolve(label: Label, position: Vector) = {
    positions = positions.put(label, position)
    wires = wires.map {
      case (a, b) => (a.resolveWire(label, position), b.resolveWire(label, position))
    }
  }

  try layout { (state.net)() }
  with emit[Agent] { agent =>
    do emit(agent)
    val triangle = Triangle(agent.pos, 100.0, agent.aux.size)
    agent.pp.resolve(triangle.principal)
    agent.aux.foreachIndex { (i, port) => port.resolve(triangle.auxiliary(i)) }
    resume(do emit(triangle))
  }
  with emit[Wire] { wire =>
    do emit(wire)
    val from = positions.get(wire.from).map { pos => Resolved(pos) }.getOrElse { Unresolved(wire.from) }
    val to   = positions.get(wire.to).map   { pos => Resolved(pos) }.getOrElse { Unresolved(wire.to) }
    resume((wires = Cons((from, to), wires)))
  }

  wires.foreach {
    case (Resolved(from), Resolved(to)) => do emit(Arrow(from, to))
    case _ => panic("unresolved wires (should be impossible by now)")
  }
}

def render(state: NetState): NetState = {
  val t: (Canvas, Net) = returning::collect {
    val canvas = state.canvas.draw { state.render() }
    canvas
  }
  NetState(t.second, t.first)
}

def setCanvasSize(state: NetState, size: Vector): NetState = {
  NetState(state.net, state.canvas.setCanvasSize(size)).render()
}

def load(state: NetState) { prog: => Unit / NetStream }: NetState = {
  val net: Net = collect { prog() }
  NetState(net, state.canvas)
}