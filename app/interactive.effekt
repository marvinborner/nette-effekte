import map

import lib/net/net
import lib/ui/geometry
import lib/ui/canvas
import lib/net/layout

record NetState(net: Net, canvas: Canvas)

def empty(): Net = box {}
def empty() = NetState(empty(), empty())

type WireResolver { Resolved(position: Vector); Unresolved(label: Label) }

def resolveWire(resolver: WireResolver, label: Label, position: Vector): WireResolver = resolver match {
  case Unresolved(l) and l == label => Resolved(position)
  case _ => resolver
}

def render(state: NetState): Unit / Geometry = {
  var positions: Map[Label, Vector] = emptyGeneric()
  var wires: List[Tuple2[WireResolver, WireResolver]] = Nil()

  def resolve(label: Label, position: Vector) = {
    positions = positions.put(label, position)
    wires = wires.map {
      case (a, b) => (a.resolveWire(label, position), b.resolveWire(label, position))
    }
  }

  try layout { (state.net)() }
  with emit[Agent] { agent =>
    val triangle = Triangle(agent.pos, 100.0, agent.aux.size)
    agent.pp.resolve(principal(triangle))
    agent.aux.foreachIndex { (i, port) => port.resolve(auxiliary(triangle, i)) }
    resume(triangle.dispatch)
  }
  with emit[Wire] { wire =>
    val from = positions.get(wire.from).map { pos => Resolved(pos) }.getOrElse { Unresolved(wire.from) }
    val to   = positions.get(wire.to).map   { pos => Resolved(pos) }.getOrElse { Unresolved(wire.to) }
    resume((wires = Cons((from, to), wires)))
  }

  wires.foreach {
    case (Resolved(from), Resolved(to)) => do arrow(from, to)
    case _ => panic("unresolved wires (should be impossible by now)")
  }
}

def render(state: NetState): NetState = {
  val canvas = applyGeometry { render(state) }
  NetState(state.net, canvas)
}

def loadNet { prog: => Unit / NetStream }: NetState = {
  val net: Net = collect { prog() } // TODO: do not collect stream
  NetState(net, empty())
}