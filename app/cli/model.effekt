import app/net

import lib/language/ic/term
import lib/language/ic/ruler
import lib/net/net
import lib/net/netter
import lib/ui/dirty
import lib/ui/terminal

record NetState(net: Net, program: Program, redexes: RedexBag, terminal: Terminal)

def empty(): Net = box {}
def empty(): Program = box {}
def empty(): RedexBag = box {}
def empty() = NetState(empty(), empty(), empty(), empty())

def stringify(redexes: RedexBag): List[String] = 
  collect[Redex] { redexes() }.map {
    case Redex(left, right) => [left.term::show, right.term::show] }.join

def load(state: NetState) { prog: => Unit / emit[Constructor] }: NetState = {
  with on[WrongFormat].panic // impossible by now
  val program: Program = collect { prog() }
  val net: Net = collect { source[Constructor] { program() } { net!() } }
  val redexes: RedexBag = collect { program.redexes() }
  NetState(net, program, redexes, Terminal(program.term::show, redexes.stringify))
}

def step(state: NetState) { stepper: (Program, RedexBag) => Unit / { emit[Constructor], emit[Redex] } }: NetState / { Redraw, fail } = {
  do redrawFull()
  val (loaded, redexes) = returning::collect {
    state.load { state.program.stepper(state.redexes) } }
  NetState(loaded.net, loaded.program, redexes, Terminal(loaded.program.term::show, redexes.stringify))
}

def cli[R] { prog: => R / NetModel[NetState, Terminal, Unit] }: R =
  try prog()
  with NetModel[NetState, Terminal, Unit] {
    def empty() = resume(empty())
    def load(net) = resume { { prog } => net.load { prog } }
    def step(net) = resume { attempt { net.step { (program, redexes) => program.step(NonDeterministic(), redexes) } } {
      => net } } // else
    def normalize(net) = resume { attempt { net.step { (program, redexes) => (program.normalize(redexes, 100).first)() } } {
      => net } } // else
    def context(net) = resume(net.terminal)

    // not relevant for cli
    def render(net) = resume { => net }
    def operation(net, op) = resume { => net }
  }
