module cli

import process
import tty

import lib/utils
import lib/ui/node
import lib/ui/view
import lib/ui/dirty
import lib/ui/terminal

import app/cli/model
import app/model

val MODE = LambdaCalculus()

def string[Ev](content: String) = String[Ev](content)
def input[Ev](handlers: List[TuiHandler[Ev]], label: String) = Input[Ev](handlers, label)
def rows[Ev](elements: List[Tui[Ev]]) = Rows[Ev](elements)
def columns[Ev](elements: List[Tui[Ev]]) = Columns[Ev](elements)

def append(text: TextStream, ch: String): String = collect { text(); ch.each }

def dropLast(text: TextStream): String =
  with on[MissingValue].default { "" }
  collect[Char] { text() }.init.map { ch => ch.show }.join("")

type Event {
  Render();
  StepReduction();
  Normalize();
  AppendSource(ch: String); // js string
  UndoSource();
  Exit();
}

// we have (very minimal) logic here to match the common interface of interactive/
def dispatch(msg: Event): Unit / { Model[Terminal, Unit], Redraw } = msg match {
  case Render()         => do render()
  case StepReduction()  => do stepReduction()
  case Normalize()      => do normalize()
  case AppendSource(ch) => do setSource(do getSource(MODE).append(ch))
  case UndoSource()     => do setSource(do getSource(MODE).dropLast)
  case Exit()           => exit(0)
}

// TODO: `or` patterns!?
def handle(key: String) = key match {
  case "\r"   => Render() // enter
  case "\n"   => Render()
  case "!"    => StepReduction()
  case "@"    => Normalize()
  case "\u8"  => UndoSource() // backspace
  case "\u7f" => UndoSource()
  case "\u3"  => Exit() // Ctrl+c
  case _      => AppendSource(key)
}

def highlight(terminal: Terminal) =
  terminal.data.split("\n").map { line =>
    if (terminal.highlighted.contains(line) { (a, b) => a == b })
      line.bold
    else
      line.dim
  }.join("\n")

def view(): Tui[Event] / { Model[Terminal, Unit], Formatted } = rows([
  columns([
    input([OnKeyPress(box { key => handle(key) })], "LC Term".green),
    string(collect { do getSource(LambdaCalculus())() }),
  ]),
  string(""),
  columns([
    string("Errors".red),
    string(do getErrors())
  ]),
  string(""),
  string("Compiled IC".green ++ " (step via '!', normalize via '@')".dim),
  string(do getContext().highlight)
])

def start() = {
  with cli
  run(empty(), model::empty[NetState, Terminal, Unit](), TuiView(
    update = box { ev =>
      with cli
      with model[Terminal, Unit, Unit, NetState]
      ev.dispatch()
    },
    view = box {
      with cli
      with model[Terminal, Unit, Tui[Event], NetState]
      with Formatted::formatting
      view()
    }))
}