// to be potentially added to Effekt's standard library

import test

type Either[A, B] { Left(a: A); Right(b: B); }

def collapse[A, B, R](port: Either[A, B]) { left: A => R } { right: B => R }: R = port match {
  case Left(a)  => left(a)
  case Right(b) => right(b)
}

// println without the ln: only for jsNode, of course
extern def print(s: String) at io: Unit =
  jsNode "process.stdout.write(${s})"
  jsWeb "console.log(${s})"
  default { println(s) }

def size[A] { s: => Unit / emit[A] }: Int = {
  var size = 0
  try s()
  with emit[A] { _ => size = size + 1}
  size
}

def choose[A] { stream: () => Unit / emit[A] }: A / fail =
  try {
    def body(): A = { stream(); first { stream() } }
    body()
  }
  with emit[A] { a =>
    if (random() > 0.5) a
    else resume(())
  }

def init[A](l: List[A]): List[A] / Exception[MissingValue] = l match {
  case Nil() => do raise(MissingValue(), "Trying to get the beginning of an empty list")
  case Cons(a, Nil()) => Nil()
  case Cons(a, as) => Cons(a, as.init)
}

def exhaustively[R](init: R) { program: () => R / fail }: R =
  var res: R = init
  try {
    def go(): R = {
      res = program()
      go()
    }
    go()
  } with fail {
    res
  }

def assertNotThrown[E](ex: on[E]) { body: => Unit / Exception[E] }: Unit / Assertion =
  ex.default { do assert(false, "Unexpected Exception") } {body}

def assertNoThrow[E] { body: => Unit / Exception[E] }: Unit / Assertion =
  on[E].default{ do assert(false, "Unexpected Exception") } {body}

def assertThrown[E](ex: on[E]) { body: => Unit / Exception[E] }: Unit / Assertion =
  do assert(ex.default { true } { body(); false }, "Expected Exception, but exited normally")

def assertThrows[E] { body: => Unit / Exception[E] }: Unit / Assertion =
  do assert(on[E].default { true } { body(); false }, "Expected Exception, but exited normally")
