// based on exercise 5 template by @jiribenes (MIT)

import ref
import string
import test

import lib/ui/node
import lib/ui/model
import lib/ui/canvas
import lib/ui/vector

type Html[Ev] {
  Text(content: String);
  Canvas(classes: List[String], handler: List[EventHandler[Ev]], canvas: Canvas)
  Element(tag: String, classes: List[String], handler: List[EventHandler[Ev]], children: List[Html[Ev]], value: String)
}

/// for better textarea experience
/// we should really be using DOM diffing or something, but this is fine
type Dirtiness { Keep(); Redraw() }

type EventHandler[Ev] {
  OnClick(handler: Ev, dirty: Dirtiness)
  OnKeyUp(handler: String => Ev at {}, dirty: Dirtiness)
  OnResize(handler: Vector => Ev at {}, dirty: Dirtiness)
}

extern type IdleDeadline

extern def requestIdleCallback(callback: (IdleDeadline) => Unit at {io, global}) at io: Unit =
  jsWeb "window.requestIdleCallback(deadline => $effekt.runToplevel((ks, k) => ${callback}(deadline, ks, k)))"

extern def style(path: String) at io: Unit =
  jsWeb "document.head.insertAdjacentHTML('beforeend', '<link rel=\"stylesheet\" href=${path} />')"

record View[St, Ev](
  update: Ev => Unit / State[St] at {io, global},
  tick: () => Unit / State[St] at {io, global},
  view: () => Html[Ev] / State[St] at {io, global}
)

def run[St, Ev](root: Node, init: St, app: View[St, Ev]) = app match {
  case View(update, tick, view) =>
    val inbox = ref[List[Ev]](Nil())
    val state = ref(init)
    val dirty = ref(true)

    def send(ev: Ev): Unit = inbox.set(Cons(ev, inbox.get))

    def handleEvent(element: Node, handler: List[EventHandler[Ev]]) = {
      handler.foreach {
        case OnClick(ev, dirtiness) =>
          element.onClick(box {
            send(ev)
            if (dirtiness is Redraw()) dirty.set(true)
          })
        case OnKeyUp(ev, dirtiness) =>
          element.onKeyUp(box { key =>
            send(ev(element.value))
            if (dirtiness is Redraw()) dirty.set(true)
          })
        case OnResize(ev, dirtiness) =>
          element.onResize(box { (initial, width, height) =>
            if (not(initial)) send(ev(Vector(width, height)))
            if (dirtiness is Redraw()) dirty.set(true)
          })
      }
    }

    // renders the Node to the DOM
    def render(html: Html[Ev]): Node = html match {
      case Text(content) => createTextNode(content)
      case Element(tag, classes, handler, children, value) =>
        val el = createElement(tag)
        el.setValue(value)
        el.handleEvent(handler)
        classes.foreach { class => el.addClass(class); () }
        children.foreach { child =>
          el.appendChild(child.render)
          ()
        }
        el
      case Canvas(classes, handler, canvas) => {
        val el = createElement("canvas")
        canvas.applyTo(el)
        el.handleEvent(handler)
        classes.foreach { class => el.addClass(class); () }
        el
      }
    }

    // renders the app with the current state
    def render(): Unit = {
      val rendered = statefully(state) { view() }.render
      if (dirty.get()) {
        root.clear;
        root.appendChild(rendered); ()
      }
      dirty.set(false)
      ()
    }

    def loop(deadline: IdleDeadline): Unit = {
      val messages = inbox.get.reverse
      inbox.set(Nil())

      if (messages.nonEmpty) {
        messages.foreach { ev =>
          with statefully(state)
          update(ev)
        }

        render()
      }
      // statefully(state) { tick() }
      requestIdleCallback(box loop)
    }

    render()
    requestIdleCallback(box loop)
}
