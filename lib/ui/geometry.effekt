import lib/ui/vector

// [-pi,pi]
type Angle = Double

// --- force ---
// values/formulae based on the Haskell GraphRewriting library by Jan Rochel (MIT)
// adapted to streams and effects

// running average
def average { f: => Unit / emit[Vector] }: Vector = {
  var s: Option[Vector] = None()
  for { f() } { v1 =>
    s = Some(s match {
      case Some(v2) => (v1 + v2) / 2.0
      case None()   => v1
    })
  }
  s.getOrElse { Vector(0.0, 0.0) }
}

interface Force {
  def origin(): Vector
  def strength(x: Double): Double
}

def forceSum { fs: => Unit / { emit[Vector], Force } }: Vector / Force =
  average { fs() }

def force(f: Vector): Vector / Force =
  do origin() + f.normalize * do strength(f.magnitude)

def repulsion(from: Vector, position: Vector): Vector / Force =
  force(position - from)

def attraction(towards: Vector, position: Vector): Vector / Force =
  force(towards - position)

// --- geometry ---

record Arrow(from: Vector, to: Vector)
record Triangle(center: Vector, width: Double, arity: Int, color: String)

effect Draw = { emit[Arrow], emit[Triangle] }
record ReifiedGeometry(arrows: List[Arrow], triangles: List[Triangle])
type Geometry = => Unit / Draw at {}

def empty(): Geometry = box{}

def draw(geometry: Geometry): Unit / Draw = geometry()

def collect { draw: => Unit / Draw }: ReifiedGeometry = {
  val tup: (List[Arrow], List[Triangle]) = returning::collect { collect { draw() } }
  ReifiedGeometry(tup.first, tup.second)
}

def collect { draw: => Unit / Draw }: Geometry = {
  val both: ReifiedGeometry = collect { draw() }
  box { both.arrows.each; both.triangles.each }
}

def height(triangle: Triangle): Double =
  triangle.width * (3.0.sqrt / 2.0)

def halfHeight(triangle: Triangle): Double =
  triangle.height / 2.0

def halfWidth(triangle: Triangle): Double =
  triangle.width / 2.0

def principal(triangle: Triangle): Vector =
  Vector(triangle.center.x, triangle.center.y - triangle.halfHeight)

def auxiliary(triangle: Triangle, index: Int): Vector = {
  val step = triangle.width / (triangle.arity + 1).toDouble
  Vector(triangle.center.x - triangle.halfWidth + (index + 1).toDouble * step, triangle.center.y + triangle.halfHeight)
}