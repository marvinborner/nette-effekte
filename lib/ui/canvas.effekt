import lib/ui/node
import lib/ui/vector
import lib/ui/context
import lib/ui/geometry

interface Handler {
  def size(canvas: Canvas, size: Vector): Canvas
}

record Canvas(geometry: Geometry, size: Vector, position: Vector, scale: Double)

def handler[R] { prog: => R / Handler } = {
  try prog()
  with Handler {
    def size(canvas, size) = <>
  }
}

def empty() = Canvas(empty(), Vector(100.0, 100.0), Vector(0.0, 0.0), 0.8)

// "drawing" in the sense of storing in Canvas structure :)
def draw(canvas: Canvas) { draw: => Unit / Draw }: Canvas = {
  val geometry: Geometry = collect { draw }
  Canvas(geometry, canvas.size, canvas.position, canvas.scale)
}

def setSize(canvas: Canvas, size: Vector): Canvas = {
  if (size.x == 0.0 || size.y == 0.0) canvas
  else Canvas(canvas.geometry, size, canvas.position, canvas.scale)
}

def map(canvas: Canvas) { f: Double => Double }: Canvas =
  Canvas(canvas.geometry, canvas.size, canvas.position, f(canvas.scale))

def restore(ctx: Context) { draw: => Unit } = {
  ctx.save()
  draw()
  ctx.restore()
}

def path(ctx: Context) { draw: => Unit } = {
  ctx.beginPath()
  draw()
  ctx.closePath()
}

def transforming(canvas: Canvas, ctx: Context) { draw: => Unit } = {
  with ctx.restore
  println(canvas.scale)
  ctx.translate(canvas.size.x / 2.0, canvas.size.y / 2.0)
  ctx.scale(canvas.scale * pixelRatio, canvas.scale * pixelRatio)
  ctx.translate(-1.0 * canvas.position.x, -1.0 * canvas.position.y)
  draw()
}

// from https://stackoverflow.com/a/8937497 + https://stackoverflow.com/a/8937325
def draw(ctx: Context, triangle: Triangle): Unit = {
  val angle = 0.0 // TODO: actually rotate
  val x = triangle.center.x + triangle.halfWidth * cos(angle)
  val y = triangle.center.y + triangle.halfHeight * sin(angle)

  with ctx.restore
  // TODO: why is this x offset required?
  ctx.translate(x - triangle.halfWidth, y)
  with ctx.path

  ctx.moveTo(0.0, -1.0 * triangle.halfHeight)
  ctx.lineTo(-1.0 * triangle.halfWidth, triangle.halfHeight)
  ctx.lineTo(triangle.halfWidth, triangle.halfHeight)
  ctx.lineTo(0.0, -1.0 * triangle.halfHeight)

  ctx.stroke()
  // ctx.fill()
}

extern def atan2(x: Double, y: Double) at io: Double =
  jsWeb "Math.atan2(${x}, ${y})"

// from https://stackoverflow.com/a/6333775
def draw(ctx: Context, arrow: Arrow): Unit = {
  with ctx.path
  val head = 10.0
  val dx = arrow.to.x - arrow.from.x
  val dy = arrow.to.y - arrow.from.y
  val angle = atan2(dy, dx)
  ctx.moveTo(arrow.from.x, arrow.from.y)
  ctx.lineTo(arrow.to.x, arrow.to.y)
  ctx.lineTo(arrow.to.x - (head * cos(angle - PI / 6.0)), arrow.to.y - head * sin(angle - PI / 6.0))
  ctx.moveTo(arrow.to.x, arrow.to.y)
  ctx.lineTo(arrow.to.x - head * cos(angle + PI / 6.0), arrow.to.y - head * sin(angle + PI / 6.0))
  ctx.stroke()
}

def applyTo(canvas: Canvas, node: Node): Unit / {} = {
  node.setSize(canvas.size.x * pixelRatio, canvas.size.y * pixelRatio)

  val ctx = node.getContext("2d")
  with canvas.transforming(ctx)

  try canvas.geometry.draw()
  with emit[Arrow] { arrow => resume(ctx.draw(arrow)) }
  with emit[Triangle] { triangle => resume(ctx.draw(triangle)) }
}