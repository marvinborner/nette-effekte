import lib/ui/geometry
import lib/ui/vector

type Kind { LightTriangle(); DarkTriangle() }

def infixEq(left: Kind, right: Kind) = (left, right) match {
  case (LightTriangle(), LightTriangle()) => true
  case (DarkTriangle(), DarkTriangle()) => true
  case _ => false // no multiplexer!
}

type Label = Int // TODO: Ref[Int]?

record Agent(name: String, pp: Label, aux: List[Label], kind: Kind, pos: Vector)
record Wire(from: Label, to: Label)

def flip(wire: Wire) = Wire(wire.to, wire.from)

def map(agent: Agent) { f: Vector => Vector }: Agent = agent match {
  case Agent(name, pp, aux, kind, pos) => Agent(name, pp, aux, kind, f(pos))
}

effect WireStream = emit[Wire]
effect AgentStream = emit[Agent]
effect NetStream = { WireStream, AgentStream }
type Net = => Unit / NetStream at {}
record ReifiedNet(wires: List[Wire], agents: List[Agent])

def agents { net: => Unit / NetStream }: Unit / AgentStream =
  try net()
  with emit[Wire] { _ => resume(()) }

def wires { net: => Unit / NetStream }: Unit / WireStream =
  try net()
  with emit[Agent] { _ => resume(()) }

def attachedTo(agent: Agent, wire: Wire) =
  wire.from == agent.pp || agent.aux.contains(wire.from) { (a, b) => a == b }
 || wire.to == agent.pp || agent.aux.contains(wire.to)   { (a, b) => a == b }

def label?(agent: Agent, label: Label) =
  agent.pp == label || agent.aux.any { l => l == label }

def arity(agent: Agent) = agent.aux.size

def color(agent: Agent) = agent.kind match {
  case LightTriangle() => "#ffffff"
  case DarkTriangle()  => "#000000"
}

def attachedWires(agent: Agent) { wires: => Unit / WireStream }: Unit / WireStream =
  for { wires() } { wire =>
    if (agent.attachedTo(wire))
      do emit(wire)
  }

def agentPositions() { agents: => Unit / AgentStream }: Unit / emit[Vector] =
  for { agents() } { agent =>
    do emit(agent.pos)
  }

/// agents connected to the given wire of the given agent, not including the agent itself
/// TODO: in our linear model, this is only 1 - stop after one emit.
def adverseAgents(agent: Agent, wire: Wire) { agents: => Unit / AgentStream }: Unit / AgentStream =
  with val a = for { agents() }
  if (a.pp != agent.pp && a.attachedTo(wire)) do emit(a)

/// gives rough positions based on agent center, not pp/aux[i]
def fromTo(wire: Wire) { agents: => Unit / AgentStream }: (Vector, Vector) = {
  var fromTo = (None[Vector](), None[Vector]())
  try agents()
  with emit[Agent] { agent =>
    if (agent.label?(wire.from)) fromTo = (Some(agent.pos), fromTo.second)
    if (agent.label?(wire.to)) fromTo = (fromTo.first, Some(agent.pos))

    // TODO: how does the `or`/`|` work in scrutinees?
    if (fromTo.first is None()) resume(())
    else if (fromTo.second is None()) resume(())
  }
  fromTo match {
    case (Some(from), Some(to)) => (from, to)
    case _ => panic("no matching positions found for wire (impossible)")
  }
}

def collect { prog: => Unit / NetStream }: ReifiedNet = {
  val tup: Tuple2[List[Wire], List[Agent]] = returning::collect { collect { prog() } }
  ReifiedNet(tup.first, tup.second)
}

def collect { prog: => Unit / NetStream }: Net = {
  val both: ReifiedNet = collect { prog() }
  box { both.wires.each; both.agents.each }
}

// TODO: make prettier
namespace returning {
  def collect[R] { prog: => R / NetStream }: (R, ReifiedNet) = {
    val tup = list::returning::collect[Agent, (R, List[Wire])] {
      list::returning::collect[Wire, R] { prog() } }
    (tup.first.first, ReifiedNet(tup.first.second, tup.second))
  }

  def collect[R] { prog: => R / NetStream }: (R, Net) = {
    val both: (R, ReifiedNet) = collect { prog() }
    (both.first, box { both.second.wires.each; both.second.agents.each })
  }
}
