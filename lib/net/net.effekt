import lib/ui/geometry
import lib/ui/vector

type Kind { LightTriangle(); DarkTriangle(); LightCircle(); DarkCircle() }

type Label = Int // TODO: Ref[Int]?

record Agent(name: String, pp: Label, aux: List[Label], kind: Kind, pos: Vector)
record Wire(from: Label, to: Label)

def mapPosition(agent: Agent) { f: Vector => Vector }: Agent = agent match {
  case Agent(name, pp, aux, kind, pos) => Agent(name, pp, aux, kind, f(pos))
}

effect WireStream = emit[Wire]
effect AgentStream = emit[Agent]
effect NetStream = { WireStream, AgentStream }
type Net = => Unit / NetStream at {}
record ReifiedNet(wires: List[Wire], agents: List[Agent])

def agents { net: => Unit / NetStream }: Unit / AgentStream =
  try net()
  with emit[Wire] { _ => resume(()) }

def wires { net: => Unit / NetStream }: Unit / WireStream =
  try net()
  with emit[Agent] { _ => resume(()) }

def attachedTo(agent: Agent, wire: Wire) =
  wire.from == agent.pp || agent.aux.contains(wire.from) { (a, b) => a == b }
 || wire.to == agent.pp || agent.aux.contains(wire.to)   { (a, b) => a == b }

def attachedWires(agent: Agent) { wires: => Unit / WireStream }: Unit / WireStream =
  for { wires() } { wire =>
    if (agent.attachedTo(wire))
      do emit(wire)
  }

def agentPositions() { agents: => Unit / AgentStream }: Unit / emit[Vector] =
  for { agents() } { agent =>
    do emit(agent.pos)
  }

// TODO: reuse returning::collect from below
def collect { prog: => Unit / NetStream }: ReifiedNet = {
  val tup: Tuple2[List[Wire], List[Agent]] = returning::collect { collect { prog() } }
  ReifiedNet(tup.first, tup.second)
}

// TODO: reuse returning::collect from below
def collect { prog: => Unit / NetStream }: Net = {
  val both: ReifiedNet = collect { prog() }
  box { both.wires.each; both.agents.each }
}

// TODO: make prettier
namespace returning {
  def collect[R] { prog: => R / NetStream }: (R, ReifiedNet) = {
    val tup = list::returning::collect[Agent, (R, List[Wire])] {
      list::returning::collect[Wire, R] { prog() } }
    (tup.first.first, ReifiedNet(tup.first.second, tup.second))
  }

  def collect[R] { prog: => R / NetStream }: (R, Net) = {
    val both: (R, ReifiedNet) = collect { prog() }
    (both.first, box { both.second.wires.each; both.second.agents.each })
  }
}