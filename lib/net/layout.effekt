// values/formulae based on the Haskell GraphRewriting library by Jan Rochel (MIT)
// adapted to streams and effects

import lib/ui/geometry
import lib/ui/vector
import lib/net/net

def centralGravitation(agent: Agent): Vector / Force =
  Vector(0.0, 0.0).attraction(agent.pos)

def coulombForce(agent: Agent) { agents: => Unit / AgentStream }: Vector / Force = {
  with forceSum
  with source[Vector] { agentPositions {agents} }

  with exhaustively
  do emit(repulsion(do read[Vector], agent.pos))
}

def geometry(wire: Wire) { agents: => Unit / AgentStream }: Tuple2[Vector, Vector] = {
  <> // based on the position of both agents its connected to
  // TODO: when "early returning" when agent is found, remember to exhaustively read all other agents (because they're potentially tee-d)
}

def springTargets(wire: Wire, agent: Agent, length: Double) { agents: => Unit / AgentStream }: Unit / emit[Vector] = {
  val (pos, direction) = wire.geometry {agents}
  do emit((pos + direction.normalize) * length) // TODO: should this somehow return multiple vectors?
}

def adverseAgents(agent: Agent, wire: Wire) { agents: => Unit / AgentStream }: Unit / emit[Agent] =
  for { agents() } { a =>
    if (a.pp != agent.pp && a.attachedTo(wire)) do emit(a)
  }

def wireForce(agent: Agent, length: Double) { agents: => Unit / AgentStream } { f: => Unit / WireStream }: Unit / { Force, emit[Vector] } =
  for { f() } { wire =>
    do emit(forceSum {
      for {
        for { agent.adverseAgents(wire) {agents} } { a =>
          wire.springTargets(a, length) {agents} }
      } { adverseTarget =>
        for { wire.springTargets(agent, length) {agents} } { agentTarget =>
          do emit(attraction(adverseTarget, agentTarget))
        }
      }
    })
  }

def springForce(agent: Agent, length: Double) { net: => Unit / NetStream }: Vector / Force =
  average { agent.wireForce(length) { agents{net} } { agent.attachedWires { wires{net} } } }

def withForce(position: Vector) { f: => Vector / Force } { s: Double => Double }: Vector  =
  try f()
  with Force {
    def origin() = resume(position)
    def strength(x) = resume(s(x))
  }

def layoutStep(agent: Agent) { net: => Unit / NetStream }: Agent = {
  val cf = withForce(agent.pos) { coulombForce(agent) { agents{net} } } {
    x => 0.2 * min(10.0, 100.0 / (pow(x, 2) + 0.1)) }
  val cgf = withForce(cf) { agent.centralGravitation } {
    x => 0.2 * min(10.0, x * 0.01) }
  // val sf = withForce(cgf) { agent.springForce(1.5) } {
  //   x => 0.2 * min(10.0, x * 0.9) }

  agent.mapPosition { _ => cgf }
  // angularMomentum(position)
}

def layout { net: => Unit / NetStream }: Unit / NetStream = {
  for[Agent] { net() } { agent =>
    do emit(agent.layoutStep {net})
  }
}