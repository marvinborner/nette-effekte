// values/formulae based on the Haskell GraphRewriting library by Jan Rochel (MIT)
// adapted to streams and effects

import lib/ui/geometry
import lib/ui/vector
import lib/net/net

def centralGravitation(agent: Agent): Vector / Force =
  Vector(0.0, 0.0).attraction(agent.pos)

def coulombForce(agent: Agent) { agents: => Unit / AgentStream }: Vector / Force =
  with forceSum
  with source[Vector] { agentPositions {agents} }
  with exhaustively
  do emit(repulsion(do read[Vector], agent.pos))

def geometry(wire: Wire) { agents: => Unit / AgentStream }: (Vector, Vector) = {
  val (from, to) = wire.fromTo {agents}
  (from, from.direction(to))
}

def springTargets(wire: Wire, agent: Agent, length: Double) { agents: => Unit / AgentStream }: Unit / emit[Vector] = {
  val (pos, direction) = wire.geometry {agents}
  do emit((pos + direction.normalize) * length) // TODO: should this somehow return multiple vectors?
}

def wireForce(agent: Agent, length: Double) { agents: => Unit / AgentStream } { f: => Unit / WireStream }: Unit / { Force, emit[Vector] } =
  with val wire = for { f() }
  do emit(forceSum {
    for {
      for { agent.adverseAgents(wire) {agents} } { a =>
        wire.springTargets(a, length) {agents} }
    } { adverseTarget =>
      for { wire.springTargets(agent, length) {agents} } { agentTarget =>
        do emit(attraction(adverseTarget, agentTarget))
      }
    }
  })

def springForce(agent: Agent, length: Double) { net: => Unit / NetStream }: Vector / Force =
  with average
  with agent.wireForce(length) { agents{net} }
  agent.attachedWires { wires{net} }

def withForce(position: Vector) { f: => Vector / Force } { s: Double => Double }: Vector  =
  try f()
  with Force {
    def origin() = resume(position)
    def strength(x) = resume(s(x))
  }

// TODO: optimize magic numbers
def layoutStep(agent: Agent) { net: => Unit / NetStream }: Agent = {
  val cf = withForce(agent.pos) { coulombForce(agent) { agents{net} } } {
    x => min(1000.0, 100000.0 / (pow(x, 2) + 1000.0)) }
  val cgf = withForce(cf) { agent.centralGravitation } {
    x => min(1000.0, x * 0.0001) }
  val sf = withForce(cgf) { agent.springForce(150.0) {net} } {
    x => min(1000.0, x * 0.009) }

  // println("old: ${agent.pos.x.show},${agent.pos.y.show} new: ${sf.x.show},${sf.y.show}")
  agent.map { _ => sf }
  // angularMomentum(position)
}

def layout { net: => Unit / NetStream }: Unit / NetStream =
  with val agent = for[Agent] { net() }
  do emit(agent.layoutStep {net})