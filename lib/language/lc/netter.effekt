// based on the Haskell implementation in my B.Sc. thesis (marvinborner/optimal-effects)

import map

import lib/utils
import lib/net/net
import lib/language/lc/term
import lib/language/ic/term

record Context(out: Port, bindings: Map[String, List[Port]])
effect port(prefix: String): Port

def plumbing { prog: => Unit / port } = {
  var i = 0
  try prog()
  with port { prefix =>
    i = i + 1
    resume(prefix ++ i.show)
  }
}

def net!(): Unit / { Exception[WrongFormat], read[Term], emit[Constructor] } = {
  with plumbing
  with loop

  val term = do read[Term]()
  val context = try term.cata
  with TermF[Int => Context / { port, emit[Constructor] } at {io}] {
    def sym(x) = resume(box { _ =>
      val px = do port(x ++ "Sym")
      Context(px, singletonGeneric(x, [px]))
    })

    def abs(x, b) = resume(box { label =>
      val Context(pb, bb) = b(label)
      val pk = do port("kAbs")
      val bound: List[Port] = bb.getOrElse(x) { Nil() }
      val px = do port(x ++ "Dup")
      do emit(Duplicator(Neg(px), bound.map { bind => Pos(bind) }, label))
      do emit(Abstractor(Pos(px), Neg(pb), Pos(pk)))
      Context(pk, bb.delete(x))
    })

    def app(f, a) = resume(box { label =>
      val Context(pf, bf) = f(label)
      val Context(pa, ba) = a(label + 1)
      val pk = do port("kApp")
      do emit(Applicator(Neg(pf), Neg(pa), Pos(pk)))
      Context(pk, bf.union(ba, box { (a, b) => a.genericCompare(b) }) { (k, a, b) => a.append(b) })
    })
  }(0)

  if (context.bindings.size > 0)
    wrongFormat("term is open: " ++ context.bindings.keys.join(", "))
}