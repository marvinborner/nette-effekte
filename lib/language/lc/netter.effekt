// based on the Haskell implementation in my B.Sc. thesis (marvinborner/optimal-effects)

import map

import lib/utils
import lib/net/net
import lib/language/lc/term
import lib/language/ic/term

record Context(out: Port, bindings: Map[String, List[Port]])
effect port(prefix: String): Port

def plumbing { prog: => Unit / port } = {
  var i = 0
  try prog()
  with port { prefix =>
    i = i + 1
    resume(prefix ++ i.show)
  }
}

def net!(): Unit / { Exception[WrongFormat], read[Term], emit[Constructor] } = {
  with plumbing
  with loop

  val term = do read[Term]()

  def bind(bindings: Map[String, List[Port]], label: Int, x: String): Port / { port, emit[Constructor] } = {
    with on[MissingValue].panic() // can not happen
    val bound: List[Port] = bindings.getOrElse(x) { Nil() } // nil is the affine-erase case

    val duplicity = bound.size
    duplicity match {
      case 0 => 
        val pk = do port(x ++ "Era")
        do emit(Duplicator(Neg(pk), [], label))
        pk
      case 1 => bound.head
      case n => {
        val pk = do port(x ++ "Dup")
        do emit(Duplicator(Neg(pk), bound.map { bind => Pos(bind) }, label))
        pk
      }
    }
  }

  val context = try term.cata
  with TermF[Int => Context / { port, emit[Constructor] } at {io}] {
    def sym(x) = resume(box { _ =>
      val px = do port(x ++ "Sym")
      Context(px, singletonGeneric(x, [px]))
    })

    def abs(x, b) = resume(box { label =>
      val Context(pb, bb) = b(label)
      val pk = do port("kAbs")
      val px = bb.bind(label, x)
      do emit(Abstractor(Pos(px), Neg(pb), Pos(pk)))
      Context(pk, bb.delete(x))
    })

    def app(f, a) = resume(box { label =>
      val Context(pf, bf) = f(label)
      val Context(pa, ba) = a(label + 1)
      val pk = do port("kApp")
      do emit(Applicator(Neg(pf), Neg(pa), Pos(pk)))
      Context(pk, bf.union(ba, box { (a, b) => a.genericCompare(b) }) { (k, a, b) => a.append(b) })
    })
  }(0)

  if (context.bindings.size > 0)
    wrongFormat("term is open: " ++ context.bindings.keys.join(", "))
  do emit(Initiator(Neg(context.out)))
}
