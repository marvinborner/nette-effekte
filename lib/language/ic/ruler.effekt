import map
import set

import lib/utils
import lib/net/net
import lib/language/ic/term

type StepMode { Deterministic(); NonDeterministic(); }

effect fresh(): Int

def freshener[R] { prog: => R / fresh }: R = {
  var counter = 0
  try prog()
  with fresh {
    counter = counter + 1
    resume(counter - 1)
  }
}

interface Rewrite {
  def annihilate(ctor: Constructor): Unit
  def construct(ctor: Constructor): Unit
  def substitute(from: SuperPort, to: SuperPort): Unit
}

def redexes(program: Program): Unit / emit[Redex] =
  with val ctorA = for { program() }
  with val ctorB = for { program() }
  if (ctorA.term::pp is Left(Neg(_)) and ctorB.term::pp is Right(Pos(_)))
    if (ctorA.pp.name == ctorB.pp.name)
      do emit(Redex(ctorA, ctorB))

def apply(port: SuperPort, substitutions: Ref[Map[SuperPort, SuperPort]]): SuperPort =
  if (substitutions.get.contains(port)) {
    val newPort = substitutions.get.getOrElse(port) { panic("wtf") }
    substitutions.map { m => m.delete(port) }
    newPort
  } else port

// Net...[x^p/y^p]...[z^p/x^p]... --> Net...[z^p/y^p]...
// Net...[z^p/x^p]...[x^p/y^p]... --> Net...[z^p/y^p]...
def apply(substitutees: Ref[Map[SuperPort, SuperPort]]) = {
  def go(): Unit = {
    var changed = false
    substitutees.get.toList.foreach { (t){label} =>
      val (to, from) = t
      if (substitutees.get.contains(from)) {
        changed = true
        val newFrom = substitutees.get.getOrElse(from) { panic("wtf") }
        substitutees.map { m => m.put(to, newFrom) }
        substitutees.map { m => m.delete(from) }
        label.break()
      }
    }
    if (changed) go()
  }
  go()
}

/// applies one-shot substitutions on constructor
def apply(ctor: Constructor, substitutions: Ref[Map[SuperPort, SuperPort]]): Constructor =
  ctor.map { p => p.apply(substitutions).name }

def interact(redex: Redex): Unit / { Rewrite, fresh } = redex match {
  // @(f-, a-, k+) <> λ(x+, b-, f+) ~> [x+/a+][b-/k-]
  // beta-reduction: APP-LAM
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Abstractor(Pos(x), Neg(b), Pos(f2))) and f1 == f2 => {
    // do substitute(Pos(x).super, Pos(a).super)
    do substitute(Neg(a).super, Neg(x).super)
    do substitute(Neg(b).super, Neg(k).super)
  }

  // δ(k-, k1+, ..., kn+) <> λ(x+, b-, k+) ~> σ(x+, x1-, ..., xn-), δ(b-, b1+, ..., bn+),
  //                                          λ(x1+, b1-, k1+), ..., λ(xn+, bn-, kn+)
  // lambda duplication: LAM-DUP
  case Redex(Duplicator(Neg(k1), ks, l), Abstractor(Pos(x), Neg(b), Pos(k2))) and k1 == k2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = ks.size
    val xs = n.list::build { i => s"${do fresh().show}" }
    val bs = n.list::build { i => s"${do fresh().show}" }
    do construct(Superposer(Pos(x), xs.map { xi => Neg(xi) }, l))
    do construct(Duplicator(Neg(b), bs.map { bi => Pos(bi) }, l))
    0.each(n) { i =>
      do construct(Abstractor(Pos(xs.get(i)), Neg(bs.get(i)), ks.get(i)))
    }
  }

  // @(f-, a-, k+) <> σ(f+, f1-, ..., fn-) ~> σ(k+, k1-, ..., kn-), δ(a-, a1+, ..., an+),
  //                                          @(f1-, a1-, k1+), ..., @(fn-, an-, kn+)
  // application superposition: SUP-APP
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Superposer(Pos(f2), fs, l)) and f1 == f2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = fs.size
    val ks = n.list::build { i => s"${do fresh().show}" }
    val as = n.list::build { i => s"${do fresh().show}" }
    do construct(Superposer(Pos(k), ks.map { ki => Neg(ki) }, l))
    do construct(Duplicator(Neg(a), as.map { ai => Pos(ai) }, l))
    0.each(n) { i =>
      do construct(Applicator(fs.get(i), Neg(as.get(i)), Pos(ks.get(i))))
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> [i1-/o1-]...[in-/on-]
  // symmetric duplicator annihilation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 == l2 and out.size == ins.size => {
    list::zip(out, ins).foreach { case (o, i) =>
      do substitute(i.super, o.negate.super)
      // do substitute(o.super, i.negate.super)
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> δ(i1-, o11+, ..., o1n+), .m., δ(im-, om1+, ..., omn+),
  //                                                 σ(o1+, o11-, ..., om1-), .n., σ(on+, o1n-, ..., omn-)
  // duplicator commutation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 != l2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = out.size
    val m = ins.size
    0.each(m) { i => // duplicators
      val outM = n.list::build { j =>
        Pos(s"${do fresh().show}")
      }
      do construct(Duplicator(ins.get(i), outM, l1))
    }
    0.each(n) { i => // superposers
      val insN = m.list::build { j =>
        Neg(s"${do fresh().show}")
      }
      do construct(Superposer(out.get(i), insN, l2))
    }
  }
  
  case _ => {
    // inspect(redex)
    panic("invalid redex")
  }
}

def step_(program: Program, redex: Redex): Unit / { emit[Constructor], fresh } = {
  val annihilated = ref[Set[Constructor]](emptyGeneric())
  val substitutions = ref[Map[SuperPort, SuperPort]](emptyGeneric())

  try {
    redex.interact()
    do annihilate(redex.left)
    do annihilate(redex.right)
  } with Rewrite {
    def annihilate(ctor) = resume(annihilated.map { s => s.insert(ctor) })
    def construct(ctor) = resume(do emit(ctor))
    def substitute(from, to) = resume(substitutions.map { m => m.put(to, from) })
  }

  // print("\nsubst before: ")
  // substitutions.get.foreach { (to, from) => print("${from.show}/${to.show}, ") }
  substitutions.apply()
  // print("\n subst after: ")
  // substitutions.get.foreach { (to, from) => print("${from.show}/${to.show}, ") }
  // println("\n")

  for { program() } { ctor =>
    if (not(annihilated.get.contains(ctor)))
      do emit(ctor.apply(substitutions))
  }
}

def choose(mode: StepMode, redexes: RedexBag): Redex / fail = mode match {
  case Deterministic()    => first[Redex] { redexes() }
  case NonDeterministic() => choose { redexes() }
}

// TODO: emit new redexes directly during interactions (wires get reconnected, check if same port)
def step(program: Program, mode: StepMode, redexes: RedexBag): Unit / { emit[Constructor], emit[Redex], fresh, fail } = {
  val redex = choose(mode, redexes)
  // println("\nREDEX: " ++ redex.left.show ++ " - " ++ redex.right.show)
  val program: Program = collect { program.step_(redex) }

  // println(list::collect[Constructor] { program() }.show { ctor => ctor.show })

  // val posPorts = collect[Constructor] { program() }.flatMap { ctor => ctor.ports }.filter { p => p.isPos }
  // val negPorts = collect[Constructor] { program() }.flatMap { ctor => ctor.ports }.filter { p => p.isNeg }
  // if (posPorts.size != negPorts.size + 1)
  //   println(s"\n!!! Pos ${posPorts.size.show} != Neg ${negPorts.size.show}: " ++ posPorts.show { p => p.name } ++ " vs " ++ negPorts.show { p => p.name })

  program.redexes() // TODO: this could be an expensive call, we should not do it at every step.
  program()
}

def normalize(program: Program, redexes: RedexBag, max: Int): (Program, Int) = {
  // println("\n\n=== NORMALIZATION ===\n")
  var count = 0
  var state = (program, redexes)

  with freshener
  with exhaustively((empty(), 0))
  count = count + 1
  state = returning::collect {
    collect { state.first.step(NonDeterministic(), state.second) } }
  if (count > max) do fail()
  (state.first, count)
}