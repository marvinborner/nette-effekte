import map
import set

import lib/utils
import lib/net/net
import lib/language/ic/term

type StepMode { Deterministic(); NonDeterministic(); }

effect fresh(): Int

def freshener[R] { prog: => R / fresh }: R = {
  var counter = 0
  try prog()
  with fresh {
    counter = counter + 1
    resume(counter - 1)
  }
}

interface Rewrite {
  def annihilate(ctor: Constructor): Unit
  def construct(ctor: Constructor): Unit
  def substitute(from: SuperPort, to: SuperPort): Unit
}

def redexes(program: Program): Unit / emit[Redex] =
  with val ctorA = for { program() }
  with val ctorB = for { program() }
  if (ctorA.term::pp is Left(Neg(_)) and ctorB.term::pp is Right(Pos(_)))
    if (ctorA.pp.name == ctorB.pp.name)
      do emit(Redex(ctorA, ctorB))

def apply(port: SuperPort, substitutions: Ref[Map[SuperPort, SuperPort]]): SuperPort =
  if (substitutions.get.contains(port)) {
    val newPort = substitutions.get.getOrElse(port) { panic("wtf") }
    substitutions.map { m => m.delete(port) }
    newPort
  } else port

/// applies one-shot substitutions on constructor
def apply(ctor: Constructor, substitutions: Ref[Map[SuperPort, SuperPort]]): Constructor =
  ctor.map { p => p.apply(substitutions).name }

def interact(redex: Redex): Unit / { Rewrite, fresh } = redex match {
  // @(f-, a-, k+) <> λ(x+, x-, f+) ~> [a-/k-]
  // identitary beta-reduction: APP-LAM
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Abstractor(Pos(x1), Neg(x2), Pos(f2))) and f1 == f2 and x1 == x2 => {
    do substitute(Neg(a).super, Neg(k).super)
  }

  // @(f-, a-, k+) <> λ(x+, x-, f+) ~> [a-/k-]
  // beta-reduction: APP-LAM
  // case Redex(Applicator(Neg(f1), Neg(a1), Pos(a2)), Abstractor(Pos(x), Neg(b), Pos(f2))) and f1 == f2 and a1 == a2 => {
  //   do substitute(Neg(b).super, Neg(x).super)
  // }

  // @(f-, a-, k+) <> λ(x+, b-, f+) ~> [a-/x-][b-/k-]
  // beta-reduction: APP-LAM
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Abstractor(Pos(x), Neg(b), Pos(f2))) and f1 == f2 => {
    do substitute(Neg(a).super, Neg(x).super)
    do substitute(Neg(b).super, Neg(k).super)
  }

  // δ(k-, k1+, ..., kn+) <> λ(x+, x-, k+) ~> λ(x1+, x1-, k1+), ..., λ(xn+, xn-, kn+)
  // identitary lambda duplication: LAM-DUP
  case Redex(Duplicator(Neg(k1), ks, l), Abstractor(Pos(x1), Neg(x2), Pos(k2))) and k1 == k2 and x1 == x2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = ks.size
    0.each(n) { i =>
      val x = s"${x1}_${do fresh().show}_${i.show}"
      do construct(Abstractor(Pos(x), Neg(x), ks.get(i)))
    }
  }

  // δ(k-, k1+, ..., kn+) <> λ(x+, b-, k+) ~> σ(x+, x1-, ..., xn-), δ(b-, b1+, ..., bn+),
  //                                          λ(x1+, b1-, k1+), ..., λ(xn+, bn-, kn+)
  // lambda duplication: LAM-DUP
  case Redex(Duplicator(Neg(k1), ks, l), Abstractor(Pos(x), Neg(b), Pos(k2))) and k1 == k2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = ks.size
    val xs = n.list::build { i => s"${x}_${do fresh().show}_${i.show}" }
    val bs = n.list::build { i => s"${b}_${do fresh().show}_${i.show}" }
    do construct(Superposer(Pos(x), xs.map { xi => Neg(xi) }, l))
    do construct(Duplicator(Neg(b), bs.map { bi => Pos(bi) }, l))
    0.each(n) { i =>
      do construct(Abstractor(Pos(xs.get(i)), Neg(bs.get(i)), ks.get(i)))
    }
  }

  // @(f-, a-, k+) <> σ(f+, f1-, ..., fn-) ~> σ(k+, k1-, ..., kn-), δ(a-, a1+, ..., an+),
  //                                          @(f1-, a1-, k1+), ..., @(fn-, an-, kn+)
  // application superposition: SUP-APP
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Superposer(Pos(f2), fs, l)) and f1 == f2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = fs.size
    val ks = n.list::build { i => s"${k}_${do fresh().show}_${i.show}" }
    val as = n.list::build { i => s"${a}_${do fresh().show}_${i.show}" }
    do construct(Superposer(Pos(k), ks.map { ki => Neg(ki) }, l))
    do construct(Duplicator(Neg(a), as.map { ai => Pos(ai) }, l))
    0.each(n) { i =>
      do construct(Applicator(fs.get(i), Neg(as.get(i)), Pos(ks.get(i))))
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> [i1-/o1-]...[in-/on-]
  // symmetric duplicator annihilation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 == l2 and out.size == ins.size => {
    list::zip(out, ins).foreach { case (o, i) =>
      do substitute(i.super, o.negate.super)
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> [i1-/o1-]...[in-/on-]
  // assymmetric duplicator annihilation: DUP-SUP TODO: COULD THIS EVER HAPPEN in EAL TYPED?
  // case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 == l2 and out.size != ins.size => {
  //   with on[OutOfBounds].panic() // can not happen
  //   val n = out.size
  //   val m = ins.size
  //   if (n > m) {
  //     val count = n / m
  //     0.each(m) { i =>
  //       do construct(Duplicator(ins.get(i), out.slice(i * count, (i + 1) * count), l1))
  //     }
  //   } else {
  //     val count = m / n
  //     0.each(n) { i =>
  //       do construct(Superposer(out.get(i), ins.slice(i * count, (i + 1) * count), l2))
  //     }
  //   }
  // }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> δ(i1-, o11+, ..., o1n+), .m., δ(im-, om1+, ..., omn+),
  //                                                 σ(o1+, o11-, ..., om1-), .n., σ(on+, o1n-, ..., omn-)
  // duplicator commutation: DUP-SUP // TODO: label management?
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 != l2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = out.size
    val m = ins.size
    val it = if (n > m) out.map { p => p.name } else ins.map { p => p.name } // interconnection labels (optimally fresh)
    0.each(m) { i => // duplicators
      val outM = n.list::build { j =>
        Pos(s"${it.get(i)}_${do fresh().show}_${j.show}")
      }
      do construct(Duplicator(ins.get(i), outM, l1))
    }
    0.each(n) { i => // superposers
      val insN = m.list::build { j =>
        Neg(s"${it.get(j)}_${do fresh().show}_${i.show}")
      }
      do construct(Superposer(out.get(i), insN, l2))
    }
  }
  
  case _ => {
    inspect(redex)
    panic("invalid redex")
  }
}

def step_(program: Program, redex: Redex): Unit / { emit[Constructor], fresh } = {
  val annihilated = ref[Set[Constructor]](emptyGeneric())
  val substitutions = ref[Map[SuperPort, SuperPort]](emptyGeneric())

  try {
    redex.interact()
    do annihilate(redex.left)
    do annihilate(redex.right)
  } with Rewrite {
    def annihilate(ctor) = resume(annihilated.map { s => s.insert(ctor) })
    def construct(ctor) = resume(do emit(ctor))
    def substitute(from, to) = resume(substitutions.map { m => m.put(to, from) })
  }

  for { program() } { ctor =>
    if (not(annihilated.get.contains(ctor)))
      do emit(ctor.apply(substitutions))
  }
}

def choose(mode: StepMode, redexes: RedexBag): Redex / fail = mode match {
  case Deterministic()    => first[Redex] { redexes() }
  case NonDeterministic() => choose { redexes() }
}

// TODO: emit new redexes directly during interactions (wires get reconnected, check if same port)
def step(program: Program, mode: StepMode, redexes: RedexBag): Unit / { emit[Constructor], emit[Redex], fresh, fail } = {
  val redex = choose(mode, redexes)
  val program: Program = collect { program.step_(redex) }
  program.redexes() // TODO: this could be an expensive call, we should not do it at every step.
  program()
}

def normalize(program: Program, redexes: RedexBag, max: Int): (Program, Int) = {
  var count = 0
  var state = (program, redexes)

  with freshener
  with exhaustively((empty(), 0))
  count = count + 1
  state = returning::collect {
    collect { state.first.step(NonDeterministic(), state.second) } }
  if (count > max) do fail()
  (state.first, count)
}