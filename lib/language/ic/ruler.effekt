import map
import set

import lib/utils
import lib/net/net
import lib/language/ic/term

type StepMode { Deterministic(); NonDeterministic(); }

record Substitution(from: SuperPort, to: SuperPort)

effect fresh(): Int

def freshener[R] { prog: => R / fresh }: R = {
  var counter = 0
  try prog()
  with fresh {
    counter = counter + 1
    resume(counter - 1)
  }
}

interface Interact {
  def annihilate(ctor: Constructor): Unit
  def construct(ctor: Constructor): Unit
  def substitute(substitution: Substitution): Unit

  def potential(port: PortRef): Unit
  def target(from: String): SuperPort
  def wire(from: Neg, to: Pos): Unit
}

def redexes(program: Program): Unit / emit[Redex] =
  with val ctorA = for { program() }
  with val ctorB = for { program() }
  if (ctorA.term::pp is Left(Neg(_)) and ctorB.term::pp is Right(Pos(_)))
    if (ctorA.canInteract && ctorB.canInteract && ctorA.pp.name == ctorB.pp.name)
      do emit(Redex(ctorA, ctorB))

// TODO: this is horribly inefficient for now, but could be very efficient
def redexes(program: Program, potential: List[PortRef]): Unit / emit[Redex] =
  with val ref = potential.foreach
  val port = ref.get
  with val ctorA = for { program() }
  with val ctorB = for { program() }
  if (ctorA.term::pp is Left(Neg(_)) and ctorB.term::pp is Right(Pos(_)))
    if (ctorA.canInteract && ctorB.canInteract && ctorA.pp.name == port && ctorB.pp.name == port)
      do emit(Redex(ctorA, ctorB))

def freshWires(n: Int): (List[Neg], List[Pos]) / { Interact, fresh } = n.list::build { i =>
  val x = do fresh().show
  val from = Neg(x.ref)
  val to = Pos(x.ref)
  do wire(from, to)
  (from, to)
}.unzip

def interact(redex: Redex): Unit / { Interact, fresh } = redex match {
  // @(f-, a-, k+) <> λ(x+, b-, f+) ~> [a-/x-][b-/k-]
  // beta-reduction: APP-LAM
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Abstractor(Pos(x), Neg(b), Pos(f2))) and f1 == f2 => {
    do substitute(Substitution(Neg(a).super, do target(Pos(x).show)))
    do substitute(Substitution(Neg(b).super, do target(Pos(k).show)))
    do potential(a) // TODO: theoretically, we'd only need to somehow check if Neg(a) is at a principal port
    do potential(b)
  }

  // δ(k-, k1+, ..., kn+) <> λ(x+, b-, k+) ~> σ(x+, x1-, ..., xn-), δ(b-, b1+, ..., bn+),
  //                                          λ(x1+, b1-, k1+), ..., λ(xn+, bn-, kn+)
  // lambda duplication: LAM-DUP
  case Redex(Duplicator(Neg(k1), ks, l), Abstractor(Pos(x), Neg(b), Pos(k2))) and k1 == k2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = ks.size
    val (xsNeg, xsPos) = n.freshWires()
    val (bsNeg, bsPos) = n.freshWires()
    do construct(Superposer(Pos(x), xsNeg, l))
    do construct(Duplicator(Neg(b), bsPos, l))
    0.each(n) { i =>
      do construct(Abstractor(xsPos.get(i), bsNeg.get(i), ks.get(i)))
    }
    do potential(x)
    do potential(b)
    ks.foreach { k => do potential(k.port) }
  }

  // @(f-, a-, k+) <> σ(f+, f1-, ..., fn-) ~> σ(k+, k1-, ..., kn-), δ(a-, a1+, ..., an+),
  //                                          @(f1-, a1-, k1+), ..., @(fn-, an-, kn+)
  // application superposition: SUP-APP
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Superposer(Pos(f2), fs, l)) and f1 == f2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = fs.size
    val (ksNeg, ksPos) = n.freshWires()
    val (asNeg, asPos) = n.freshWires()
    do construct(Superposer(Pos(k), ksNeg, l))
    do construct(Duplicator(Neg(a), asPos, l))
    0.each(n) { i =>
      do construct(Applicator(fs.get(i), asNeg.get(i), ksPos.get(i)))
    }
    fs.foreach { f => do potential(f.port) }
    do potential(a)
    do potential(k)
  }

  // δ(k-) <> σ(k+, i1-, ..., im-) ~> δ(i1-), ..., δ(in-)
  // asymmetric eraser annihilation: DUP-SUP
  case Redex(Duplicator(Neg(k1), Nil(), l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 => {
    ins.foreach { i =>
      do construct(Duplicator(i, Nil(), l1))
      do potential(i.port)
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+) ~> σ(o1+), ..., σ(on+)
  // asymmetric coeraser annihilation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), Nil(), l2)) and k1 == k2 => {
    out.foreach { o =>
      do construct(Superposer(o, Nil(), l2))
      do potential(o.port)
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> [i1-/o1-]...[in-/on-]
  // symmetric duplicator annihilation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 == l2 and out.size == ins.size => {
    list::zip(out, ins).foreach { case (o, i) =>
      // TODO: pre-substitute
      do substitute(Substitution(i.super, do target(o.show)))
      do potential(i.port)
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> δ(i1-, o11+, ..., o1n+), .m., δ(im-, om1+, ..., omn+),
  //                                                 σ(o1+, o11-, ..., om1-), .n., σ(on+, o1n-, ..., omn-)
  // duplicator commutation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 != l2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = out.size
    val m = ins.size
    val d = max(n, m)

    0.each(d) { i =>
      val (insN, outM) = d.freshWires() // TODO: this constructs additional wires in unbalanced dups
      if (i < m) {
        do construct(Duplicator(ins.get(i), outM.take(m), l1))
      }
      if (i < n) {
        do construct(Superposer(out.get(i), insN.take(n), l2))
      }
    }

    ins.foreach { i => do potential(i.port) }
    out.foreach { o => do potential(o.port) }
  }
  
  case _ => {
    inspect(redex)
    panic("invalid redex")
  }
}

/// build up a static, doubly linked relationship between positive and negative ports
/// the relationship is from SuperPort.show to SuperPort
def wiring(program: Program): Map[String, SuperPort] = {
  var wiring: Map[String, SuperPort] = emptyGeneric() // pname -> target port
  var map: Map[String, SuperPort] = emptyGeneric() // name -> own port

  def link(port: SuperPort): Unit = {
    map.get(port.name) match {
      case Some(target) =>
        wiring = wiring.put(port.show, target).put(target.show, port)
      case None() =>
        map = map.put(port.name, port)
    }
  }

  try program()
  with emit[Constructor] { ctor =>
    ctor.ports.foreach { port => link(port) }
    resume(())
  }
  wiring
}

def substitute(substitution: Substitution, wiring: Ref[Map[String, SuperPort]]) = {
  val Substitution(from, to) = substitution
  println(s"[${from.show}/${to.show}]")
  // val x = to.port.get
  to.port.set(from.port.get)
  // from.port.set(x)
  wiring.map { w => w.put(to.show, from).put(from.show, to) }
}

def step_(program: Program, redex: Redex): List[PortRef] / { emit[Constructor], fresh } = {
  val annihilated = ref[Set[Constructor]](emptyGeneric())
  val constructed = ref[List[Constructor]](Nil())
  val potential = ref[List[PortRef]](Nil())
  val wiring = ref(program.wiring())

  println(program.show)

  try {
    redex.interact()
    do annihilate(redex.left)
    do annihilate(redex.right)
  } with Interact {
    def annihilate(ctor) = resume(annihilated.map { s => s.insert(ctor) })
    def construct(ctor) = resume(do emit(ctor))
    def substitute(substitution) = resume(substitution.substitute(wiring))
    def potential(port) = resume(potential.map { l => Cons(port, l) })
    def target(from) = resume(wiring.get.getOrElse(from) { panic(s"invalid target: ${from.show}") })
    def wire(from, to) = resume(wiring.map { w => w.put(from.show, to.super).put(to.show, from.super) })
  }

  println("\nemitting:")
  for { program() } { ctor =>
    if (not(annihilated.get.contains(ctor))) {
      println(ctor.show)
      do emit(ctor)
    }
  }

  potential.get
}

def pop[A] { stream: => Unit / emit[A] }: A / { fail, emit[A] } = {
  try {
    def body(): Option[A] = { stream(); None() }
    body()
  } with emit[A] { a =>
    val next = resume(())
    if (next is Some(a)) do emit(a)
    Some(a)
  }.getOrFail
}

def pop(mode: StepMode, redexes: RedexBag): Redex / { fail, emit[Redex] } = mode match {
  case Deterministic()    => pop[Redex] { redexes() }
  case NonDeterministic() => choose { redexes() } // TODO
}

def step(program: Program, mode: StepMode, redexes: RedexBag): Unit / { emit[Constructor], emit[Redex], fresh, fail } = {
  //val redex = pop(mode, redexes) // TODO!
  val redex = pop(NonDeterministic(), redexes)
  println(s"\n=== REDEX: ${redex.show} ===")
  val tup: (List[PortRef], Program) = returning::collect { program.step_(redex) }
  val (potential, program) = tup

  // println(list::collect[Constructor] { program() }.show { ctor => ctor.show })

  // only for debugging
  val posPorts = collect[Constructor] { program() }.flatMap { ctor => ctor.ports }.filter { p => p.isPos }.map { p => p.name }.set::fromListGeneric
  val negPorts = collect[Constructor] { program() }.flatMap { ctor => ctor.ports }.filter { p => p.isNeg }.map { p => p.name }.set::fromListGeneric
  if (posPorts.difference(negPorts).size != 0) {
    println("\n!!! FATAL " ++ posPorts.toList.show ++ " vs " ++ negPorts.toList.show)
    // println("\nREDEX: " ++ redex.left.show ++ " - " ++ redex.right.show)
    println(posPorts.difference(negPorts).toList.show)
  } else {
    // println(potential)
    //program.redexes(potential)
    program.redexes()
    program()
  }
}

def normalize(program: Program, redexes: RedexBag, max: Int): (Program, Int) = {
  // println("\n\n=== NORMALIZATION ===\n")
  var count = 0
  var state = (program, redexes)

  with freshener
  with exhaustively((empty(), 0))
  count = count + 1
  state = returning::collect {
    collect { state.first.step(Deterministic(), state.second) } }
  if (count > max) do fail()
  (state.first, count)
}
