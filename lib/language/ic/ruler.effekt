import map
import set

import lib/utils
import lib/net/net
import lib/language/ic/term

type StepMode { Deterministic(); NonDeterministic(); }

interface Rewrite {
  def annihilate(ctor: Constructor): Unit
  def construct(ctor: Constructor): Unit
  def substitute(from: SuperPort, to: SuperPort): Unit
}

def redexes(program: Program): Unit / emit[Redex] =
  with val ctorA = for { program() }
  with val ctorB = for { program() }
  if (ctorA.term::pp is Left(Neg(_)) and ctorB.term::pp is Right(Pos(_)))
    if (ctorA.pp.name == ctorB.pp.name)
      do emit(Redex(ctorA, ctorB))

def apply(port: SuperPort, substitutions: Ref[Map[SuperPort, SuperPort]]): SuperPort =
  if (substitutions.get.contains(port)) {
    val newPort = substitutions.get.getOrElse(port) { panic("wtf") }
    substitutions.map { m => m.delete(port) }
    newPort
  } else port

/// applies one-shot substitutions on constructor
def apply(ctor: Constructor, substitutions: Ref[Map[SuperPort, SuperPort]]): Constructor =
  ctor.map { p => p.apply(substitutions).name }

def interact(redex: Redex): Unit / Rewrite = redex match {
  // @(f-, a-, k+) <> λ(x+, b-, f+) ~> [a-/x-][b-/k-]
  // beta-reduction: APP-LAM
  case Redex(Applicator(Neg(f1), Neg(a), Pos(k)), Abstractor(Pos(x), Neg(b), Pos(f2))) and f1 == f2 => {
    do substitute(Neg(a).super, Neg(x).super)
    do substitute(Neg(b).super, Neg(k).super)
  }

  // δ(k-, k1+, ..., kn+) <> λ(x+, b-, k+) ~> σ(x+, x1-, ..., xn-), δ(b-, b1+, ..., bn+),
  //                                          λ(x1+, b1-, k1+), ..., λ(xn+, bn-, kn+)
  // lambda duplication: LAM-DUP
  case Redex(Duplicator(Neg(k1), ks, l), Abstractor(Pos(x), Neg(b), Pos(k2))) and k1 == k2 => {
    with on[OutOfBounds].panic() // can not happen
    val n = ks.size
    val xs = n.list::build { i => s"${x}_${i.show}" }
    val bs = n.list::build { i => s"${b}_${i.show}" }
    do construct(Superposer(Pos(x), xs.map { xi => Neg(xi) }, l))
    do construct(Duplicator(Neg(b), bs.map { bi => Pos(bi) }, l))
    0.each(n) { i =>
      do construct(Abstractor(Pos(xs.get(i)), Neg(bs.get(i)), ks.get(i)))
    }
  }

  // δ(k-, o1+, ..., on+) <> σ(k+, i1-, ..., im-) ~> [i1-/o1-]...[in-/on-]
  // duplicator annihilation: DUP-SUP
  case Redex(Duplicator(Neg(k1), out, l1), Superposer(Pos(k2), ins, l2)) and k1 == k2 and l1 != l2 and out.size == ins.size => {
    list::zip(out, ins).foreach { case (o, i) =>
      do substitute(i.super, o.negate.super)
    }
  }
  
  case _ => {
    inspect(redex)
    panic("invalid redex")
  }
}

def step_(program: Program, redex: Redex): Unit / emit[Constructor] = {
  val annihilated = ref[Set[Constructor]](emptyGeneric())
  val substitutions = ref[Map[SuperPort, SuperPort]](emptyGeneric())

  try {
    redex.interact()
    do annihilate(redex.left)
    do annihilate(redex.right)
  } with Rewrite {
    def annihilate(ctor) = resume(annihilated.map { s => s.insert(ctor) })
    def construct(ctor) = resume(do emit(ctor))
    def substitute(from, to) = resume(substitutions.map { m => m.put(to, from) })
  }

  for { program() } { ctor =>
    if (not(annihilated.get.contains(ctor)))
      do emit(ctor.apply(substitutions))
  }
}

def choose(mode: StepMode, redexes: RedexBag): Redex / fail = mode match {
  case Deterministic()    => first[Redex] { redexes() }
  case NonDeterministic() => choose { redexes() }
}

// TODO: emit new redexes directly during interactions (wires get reconnected, check if same port)
def step(program: Program, mode: StepMode, redexes: RedexBag): Unit / { emit[Constructor], emit[Redex], fail } = {
  val redex = choose(mode, redexes)
  val program: Program = collect { program.step_(redex) }
  program.redexes() // TODO: this could be an expensive call, we should not do it at every step.
  program()
}

def normalize(program: Program, redexes: RedexBag, max: Int): (Program, Int) = {
  var count = 0
  var state = (program, redexes)

  with exhaustively((empty(), 0))
  count = count + 1
  state = returning::collect {
    collect { state.first.step(Deterministic(), state.second) } }
  if (count > max) do fail()
  (state.first, count)
}