import lib/net/net
import lib/language/ic/term
import lib/language/lexer
import lib/language/parser

def parsePolarity(): Polarity / Parser = or {
  punct("+")
  Pos()
} {
  punct("-")
  Neg()
}

def parsePort(): Port / Parser = {
  val name = ident()
  val pol = parsePolarity()
  Port(name, pol)
}

def parseConstructor(): Constructor / Parser = {
  val pp = parsePort()
  punct("(")
  val aux = some {
    val port = parsePort()
    opt { punct(",") }
    port
  }
  punct(")")
  Constructor(pp, aux, LightTriangle())
}

def parseProgram(): List[Constructor] / Parser = some { parseConstructor() }

// TODO: make this stream-based?
def parseS(input: String): List[Constructor] / Exception[WrongFormat] =
  try { lexer(input) { skipWhitespace { Success(parseProgram()) }}}
  with Nondet {
    def alt() = resume(true) match {
      case Error(_, _) => resume(false)
      case Success(res) => Success(res)
    }
    def fail(msg) = Error(WrongFormat(), msg)
  }
  with LexerError { (msg, pos) => Error(WrongFormat(), "${pos.show}: ${msg}") }
  .value

// TODO: also support parsing rules (emit[Rule])
//   "! f-(a-, k+) <> f+(x+, b-) ~> [a-/x-][k-/b-]"
def parse!(): Unit / { Exception[WrongFormat], read[Char], emit[Constructor] } =
  parseS(collect { exhaustively { do emit(do read[Char]()) } }).each