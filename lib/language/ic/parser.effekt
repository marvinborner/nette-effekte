import lib/net/net
import lib/language/ic/term
import lib/language/lexer
import lib/language/parser

def parsePolarity(): Polarity / Parser = or {
  punct("+")
  Pos()
} {
  punct("-")
  Neg()
}

def parsePort(): Port / Parser = {
  val name = ident()
  val pol = parsePolarity()
  Port(name, pol)
}

def parseConstructor(): Constructor / Parser = {
  val pp = parsePort()
  val kind = or([
    box { punct("("); LightTriangle() },
    box { punct("["); DarkTriangle() },
  ])
  val aux = some {
    val port = parsePort()
    opt { punct(",") }
    port
  }
  kind match {
    case LightTriangle() => punct(")")
    case DarkTriangle() => punct("]")
  }
  Constructor(pp, aux, kind)
}

def parseProgram(): List[Constructor] / Parser = some { parseConstructor() }

// TODO: make this stream-based?
def parseS(input: String): List[Constructor] / Exception[WrongFormat] =
  try { lexer(input) { skipWhitespace { Success(parseProgram()) }}}
  with Nondet {
    def alt() = resume(true) match {
      case Error(_, _) => resume(false)
      case Success(res) => Success(res)
    }
    def fail(msg) = Error(WrongFormat(), msg)
  }
  with LexerError { (msg, pos) => Error(WrongFormat(), "${pos.show}: ${msg}") }
  .value

// TODO: also support parsing rules (emit[Rule])
//   "! f-(a-, k+) <> f+(x+, b-) ~> [a-/x-][k-/b-]"
// TODO: we sometimes swallow parsing errors because everything is streamed, is there an easy fix?
def parse!(): Unit / { Exception[WrongFormat], read[Char], emit[Constructor] } = {
  parseS(collect { loop { do emit(do read[Char]()) } }).each
}