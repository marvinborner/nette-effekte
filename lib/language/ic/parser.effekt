import lib/net/net
import lib/language/ic/term
import lib/language/lexer
import lib/language/parser

def parsePos(): Pos / Parser = {
  val name = ident()
  punct("+") 
  Pos(name)
}

def parseNeg(): Neg / Parser = {
  val name = ident()
  punct("-") 
  Neg(name)
}

def parseAbstractor(): Constructor / Parser = {
  punct("λ")
  punct("(");
  val x = parsePos()
  val b = parseNeg()
  val k = parsePos()
  punct(")");
  Abstractor(x, b, k)
}

def parseApplicator(): Constructor / Parser = {
  punct("@")
  punct("(");
  val f = parseNeg()
  val a = parseNeg()
  val k = parsePos()
  punct(")");
  Applicator(f, a, k)
}

def parseDuplicator(): Constructor / Parser = {
  punct("δ")
  punct("(");
  val i = parseNeg()
  val out = many {
    parsePos()
  }
  punct(")");
  Duplicator(i, out, 0)
}

def parseSuperposer(): Constructor / Parser = {
  punct("σ")
  punct("(");
  val o = parsePos()
  val ins = many {
    parseNeg()
  }
  punct(")");
  Superposer(o, ins, 0)
}

def parseConstructor(): Constructor / Parser = {
  or([
    box { parseAbstractor() },
    box { parseApplicator() },
    box { parseDuplicator() },
    box { parseSuperposer() },
  ])
}

def parseProgram(): List[Constructor] / Parser = some { parseConstructor() }

// TODO: make this stream-based?
def parseS(input: String): List[Constructor] / Exception[WrongFormat] =
  try { lexer(input) { skipWhitespace { Success(parseProgram()) }}}
  with Nondet {
    def alt() = resume(true) match {
      case Error(_, _) => resume(false)
      case Success(res) => Success(res)
    }
    def fail(msg) = Error(WrongFormat(), msg)
  }
  with LexerError { (msg, pos) => Error(WrongFormat(), s"${pos.lexer::show}: ${msg}") }
  .value

// TODO: also support parsing rules (emit[Rule])
//   "! f-(a-, k+) <> f+(x+, b-) ~> [a-/x-][k-/b-]"
// TODO: we sometimes swallow parsing errors because everything is streamed, is there an easy fix?
def parse!(): Unit / { Exception[WrongFormat], read[Char], emit[Constructor] } = {
  parseS(collect { loop { do emit(do read[Char]()) } }).each
}