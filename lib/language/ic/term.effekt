import lib/net/net

type Polarity { Pos(); Neg() }

record Port(name: String, pol: Polarity)

def map(port: Port) { f: Polarity => Polarity }: Port = port match {
  case Port(name, pol) => Port(name, pol.f)
}

def negate(pol: Polarity) = pol match { case Pos() => Neg(); case Neg() => Pos() }
def negate(port: Port) = port.map { pol => pol.negate }

record Constructor(pp: Port, aux: List[Port], kind: Kind)
type Program = => Unit / emit[Constructor] at {}

def empty(): Program = box {}

record Redex(left: Constructor, right: Constructor) // pp: (-, +)
type RedexBag = => Unit / emit[Redex] at {}

def show(pol: Polarity) = pol match {
  case Pos() => "+"
  case Neg() => "-"
}

def show(port: Port) = port.name ++ port.pol.show()

def show(ctor: Constructor) = {
  val pp = ctor.pp.show()
  val aux = ctor.aux.map { p => p.show() }.join(", ")
  ctor.kind match {
    case LightTriangle() => "${pp}(${aux})"
    case DarkTriangle()  => "${pp}[${aux}]"
  }
}

def show(prog: Program) = {
  var res = ""
  try prog()
  with emit[Constructor] { ctor =>
    res = "${res}${ctor.show}\n"
    resume(())
  }
  res
}

def arity(ctor: Constructor) = ctor.aux.size

def collect { prog: => Unit / emit[Redex] }: RedexBag = {
  val redexes: List[Redex] = collect { prog() }
  box { redexes.each }
}

def collect { prog: => Unit / emit[Constructor] }: Program = {
  val ctors: List[Constructor] = collect { prog() }
  box { ctors.each }
}

namespace returning {
  def collect[R] { prog: => R / emit[Redex] }: (R, RedexBag) = {
    val redexes: (R, List[Redex]) = list::returning::collect { prog() }
    (redexes.first, box { redexes.second.each })
  }

  def collect[R] { prog: => R / emit[Constructor] }: (R, Program) = {
    val ctors: (R, List[Constructor]) = list::returning::collect { prog() }
    (ctors.first, box { ctors.second.each })
  }
}