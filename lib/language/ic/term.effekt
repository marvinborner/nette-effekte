import lib/utils
import lib/net/net

type Port = String
type PortRef = Ref[Port]
record Neg(port: PortRef)
record Pos(port: PortRef)
type SuperPort = Either[Neg, Pos]

def name(neg: Neg) = neg.port.get
def name(pos: Pos) = pos.port.get

def infixEq(a: PortRef, b: PortRef) = a.get == b.get
def infixEq(a: Neg, b: Neg) = a.port == b.port
def infixEq(a: Pos, b: Pos) = a.port == b.port
def infixEq(as: List[Neg], bs: List[Neg]) =
  as.size == bs.size && as.zip(bs).all { case (a, b) => a == b}
def infixEq(as: List[Pos], bs: List[Pos]) =
  as.size == bs.size && as.zip(bs).all { case (a, b) => a == b}

def show(port: Pos) = port.name ++ "+"
def show(port: Neg) = port.name ++ "-"

def super(port: Neg): SuperPort = Left(port)
def super(port: Pos): SuperPort = Right(port)

def negate(port: Neg): Pos = Pos(port.port)
def negate(port: Pos): Neg = Neg(port.port)

def port(port: SuperPort) = port match {
  case Left(p)  => p.port
  case Right(p) => p.port
}

def name(port: SuperPort) = port match {
  case Left(p)  => p.name
  case Right(p) => p.name
}

def show(port: SuperPort): String = port match {
  case Left(p)  => p.name ++ "-"
  case Right(p) => p.name ++ "+"
}

def negate(port: SuperPort) = port match {
  case Left(p)  => Right(p.negate)
  case Right(p) => Left(p.negate)
}

def isNeg(port: SuperPort) = port match {
  case Left(p)  => true
  case Right(p) => false
}

def isPos(port: SuperPort) = port match {
  case Left(p)  => false
  case Right(p) => true
}

def map(port: Pos) { f: PortRef => PortRef }: Pos = Pos(port.port.f)
def map(port: Neg) { f: PortRef => PortRef }: Neg = Neg(port.port.f)

type Constructor {
  Initiator(k: Neg);
  Abstractor(x: Pos, b: Neg, k: Pos);
  Applicator(f: Neg, a: Neg, k: Pos);
  Duplicator(o: Neg, ins: List[Pos], label: Int);
  Superposer(i: Pos, out: List[Neg], label: Int);
}

def show(ctor: Constructor) = {
  def pretty(many: List[Pos]) = many.map { p => p.show() }.join(", ")
  def pretty(many: List[Neg]) = many.map { p => p.show() }.join(", ")
  ctor match {
    case Initiator(k)              => s"ι(${k.show})"
    case Abstractor(x, b, k)       => s"λ(${x.show}, ${b.show}, ${k.show})"
    case Applicator(f, a, k)       => s"@(${f.show}, ${a.show}, ${k.show})"
    case Duplicator(o, ins, label) => s"δ(${o.show}, ${ins.pretty})(${label.show})"
    case Superposer(i, out, label) => s"σ(${i.show}, ${out.pretty})(${label.show})"
  }
}
def show(ctors: List[Constructor]) =
  "[" ++ ctors.map { ctor => ctor.show() }.join(", ") ++ "]"

def infixEq(ctor1: Constructor, ctor2: Constructor) = (ctor1, ctor2) match {
  case (Initiator(k1),                Initiator(k2)) => k1 == k2
  case (Abstractor(x1, b1, k1),       Abstractor(x2, b2, k2)) => x1 == x2 && b1 == b2 && k1 == k2
  case (Applicator(f1, a1, k1),       Applicator(f2, a2, k2)) => f1 == f2 && a1 == a2 && k1 == k2
  case (Duplicator(o1, ins1, label1), Duplicator(o2, ins2, label2)) => o1 == o2 && ins1 == ins2 && label1 == label2
  case (Superposer(i1, out1, label1), Superposer(i2, out2, label2)) => i1 == i2 && out1 == out2 && label1 == label2
  case _ => false
}
def infixEq(as: List[Constructor], bs: List[Constructor]) =
  as.size == bs.size && as.zip(bs).all { case (a, b) => a == b}

def canInteract(ctor: Constructor) = ctor match{
  case Initiator(k) => false
  case _            => true
}

type Program = => Unit / emit[Constructor] at {}
def empty(): Program = box {}

record Redex(left: Constructor, right: Constructor) // pp: (-, +)
type RedexBag = => Unit / emit[Redex] at {io, global} // finding redexes requires dereferencing Refs

def show(redex: Redex) = s"(${redex.left.show} >< ${redex.right.show})"
def show(redexes: List[Redex]) =
  "[" ++ redexes.map { redex => redex.show() }.join(", ") ++ "]"
def infixEq(a: Redex, b: Redex) = a.left == b.left && a.right == b.right
def infixEq(as: List[Redex], bs: List[Redex]) = 
  as.size == bs.size && as.zip(bs).all { case (a, b) => a == b}

def pp(ctor: Constructor): SuperPort = ctor match {
  case Initiator(k)              => k.super
  case Abstractor(x, b, k)       => k.super
  case Applicator(f, a, k)       => f.super
  case Duplicator(o, ins, label) => o.super
  case Superposer(i, out, label) => i.super
}

def aux(ctor: Constructor): List[SuperPort] = ctor match {
  case Initiator(k)              => []
  case Abstractor(x, b, k)       => [x.super, b.super]
  case Applicator(f, a, k)       => [a.super, k.super]
  case Duplicator(o, ins, label) => ins.map { i => i.super }
  case Superposer(i, out, label) => out.map { o => o.super }
}

def ports(ctor: Constructor): List[SuperPort] = Cons(ctor.pp, ctor.aux)

def map(ctor: Constructor) { func: SuperPort => PortRef }: Constructor = ctor match {
  case Initiator(k)              => Initiator(Neg(k.super.func))
  case Abstractor(x, b, k)       => Abstractor(Pos(x.super.func), Neg(b.super.func), Pos(k.super.func))
  case Applicator(f, a, k)       => Applicator(Neg(f.super.func), Neg(a.super.func), Pos(k.super.func))
  case Duplicator(i, out, label) => Duplicator(Neg(i.super.func), out.map { s => Pos(s.super.func) }, label)
  case Superposer(o, ins, label) => Superposer(Pos(o.super.func), ins.map { s => Neg(s.super.func) }, label)
}

def kind(ctor: Constructor): Kind = ctor match {
  case Initiator(k)              => LightTriangle()
  case Abstractor(x, b, k)       => LightTriangle()
  case Applicator(f, a, k)       => LightTriangle()
  case Duplicator(o, ins, label) => DarkTriangle()
  case Superposer(i, out, label) => DarkTriangle()
}

def show(prog: Program) = {
  var res = ""
  try prog()
  with emit[Constructor] { ctor =>
    res = s"${res}${ctor.show}\n"
    resume(())
  }
  res
}

def arity(ctor: Constructor) = ctor.aux.size

def collect { prog: => Unit / emit[Redex] }: RedexBag = {
  val redexes: List[Redex] = collect { prog() }
  box { redexes.each }
}

def collect { prog: => Unit / emit[Constructor] }: Program = {
  val ctors: List[Constructor] = collect { prog() }
  box { ctors.each }
}

namespace returning {
  def collect[R] { prog: => R / emit[Redex] }: (R, RedexBag) = {
    val redexes: (R, List[Redex]) = list::returning::collect { prog() }
    (redexes.first, box { redexes.second.each })
  }

  def collect[R] { prog: => R / emit[Constructor] }: (R, Program) = {
    val ctors: (R, List[Constructor]) = list::returning::collect { prog() }
    (ctors.first, box { ctors.second.each })
  }
}
